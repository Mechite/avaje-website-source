<html>
<head>
  <meta name="layout" content="_layout/base-http-client.html"/>
  <meta name="bread2" content="client" href="/http-client/"/>
  <#assign index="active">
</head>
<body>

<h1 id="overview">avaje http client</h1>

<table style="width: 100%;">
  <tr>
    <th>License</th>
    <th>Source</th>
    <th>API Docs</th>
    <th>Issues</th>
    <th>Releases</th>
  </tr>
  <tr>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/blob/master/LICENSE">Apache2</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client">Github</a></td>
    <td><a target="_blank" href="/apidocs/avaje-http-client">Javadoc</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/issues">Github</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/releases">Latest 1.13</a></td>
  </tr>
</table>
<p>&nbsp;</p>
<p>
  <a href="https://mvnrepository.com/artifact/io.avaje/avaje-http-client"><img src="https://img.shields.io/maven-central/v/io.avaje/avaje-http-client.svg?label=Maven%20Central"></a>
  <a href="https://github.com/avaje/avaje-http-client/actions/workflows/build.yml"><img src="https://github.com/avaje/avaje-http-client/actions/workflows/build.yml/badge.svg" alt="Build"></a>
  <a href="https://github.com/avaje/avaje-http-client/blob/master/LICENSE"><img alt="License" src="https://img.shields.io/badge/License-Apache%202.0-blue.svg"></a>
</p>
<p>&nbsp;</p>

<h3>Wrap JDK HttpClient</h3>
<p>
  A lightweight wrapper to the <a target="_blank" href="http://openjdk.java.net/groups/net/httpclient/intro.html">JDK 11+ Java Http Client</a>.
</p>
<ul>
  <li>Requires Java 11+ (recommend 11.0.8+)</li>
  <li>Adds a fluid API for building URL and payload</li>
  <li>Adds JSON marshalling/unmarshalling of request and response using
    <a href="https://github.com/FasterXML/jackson">Jackson</a>,
    <a href="https://github.com/google/gson">Gson</a> or <a href="https://github.com/avaje/avaje-jsonb">avaje-jsonb</a>
  </li>
  <li>Gzip encoding/decoding</li>
  <li>Logging of request/response logging</li>
  <li>Interception of request/response</li>
  <li>Built in support for authorization via Basic Auth and Bearer Token</li>
  <li>Provides async and sync API</li>
</ul>

<h3>Client API generation</h3>
<p>
  Optionally we can define a java interface with annotations and have a Java
  annotation processor generate the client implementation (similar to Retrofit,
  Feign and JAX-RS client).
</p>
<ul>
  <li>Generates the implementation as source code via annotation processing</li>
  <li>No reflection and no use of dynamic proxies</li>
  <li>Targets <em>avaje-http-client / JDK HttpClient</em> only</li>
</ul>
<p>
  This is similar to <a target="_blank" href="https://github.com/square/retrofit">Retrofit</a>,
  <a target="_blank" href="https://github.com/OpenFeign/feign">Feign</a> and JAX-RS client for people familiar with
  those projects. This client API generation targets <em>avaje-http-client / JDK HttpClient</em> only
  and uses source code generation via annotation processing so there is no use of reflection and no
  use of dynamic proxies.
</p>

<h5>Example client API</h5>
<pre content="java">
  @Client
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    List<|Contributor> contributors(String owner, String repo);
  }
</pre>

<h5>Using client API</h5>
<pre content="java">
  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl("https://api.github.com")
    //.bodyAdapter(new JacksonBodyAdapter())
    .build();

  // obtain API implementation
  GitHub github = client.create(GitHub.class);

  // use the api/interface
  List<|Contributor> contributors = github.contributors("rbygrave", "junk");
</pre>

<h5>API allowing async or sync use via HttpCall</h5>
<pre content="java">
  @Client
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    HttpCall<|Contributor> contributors(String owner, String repo);
  }
</pre>
<p>
  The client API can also be a useful target given a openapi/swagger spec.
  Given a openapi spec generate a client API (or client and server API).
  The plan is to add a maven plugin that takes an openapi spec and generates
  the associated API but this does not exist just yet.
</p>


<h2 id="getting-started">Getting started</h2>
<ul>
  <li><a href="/http-client/start">Get started with the base client</a></li>
  <li><a href="/http-client/start#api-start">Get started with Client API generation</a></li>
</ul>

<h2 id="dependencies">Dependencies</h2>

<h3 id="maven">Maven</h3>
<p>
  Add <em>avaje-http-client</em> as a dependency.
</p>
<pre content="xml">
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-client</artifactId>
    <version>1.13</version>
  </dependency>
</pre>

<h4>Client API generation</h4>
<p>
  For the client API generation we need to add <em>avaje-http-api</em> as a dependency.
</p>
<pre content="xml">
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-api</artifactId>
    <version>1.13</version>
  </dependency>
</pre>

<h4>Client API - Annotation processor</h4>
<p>
  Add the <em>avaje-http-client-generator</em> annotation processor.
  We can add it as a <em>provided</em> scope dependency or ...
</p>
<pre content="xml">
  <!-- Annotation processors -->
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-client-generator</artifactId>
    <version>1.13</version>
    <scope>provided</scope>
  </dependency>
</pre>

<p>
  If there are other annotation processors and they are specified via
  <em>maven-compiler-plugin</em> <em>annotationProcessorPaths</em>
  then we add <em>avaje-http-client-generator</em> there instead.
</p>
<pre content="xml">
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessorPaths> <!-- All annotation processors specified here -->
      <path>
        <groupId>io.avaje</groupId>
        <artifactId>avaje-http-client-generator</artifactId>
        <version>1.13</version>
      </path>
      <path>
          ... other annotation processor ...
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
</pre>

<h3 id="gradle">Gradle</h3>
<p>
  Add dependencies for <em>avaje-http-client</em> and <em>jackson-databind</em>.
</p>
<pre content="groovy">
dependencies {

  implementation 'com.fasterxml.jackson.core:jackson-databind:2.12.3'
  implementation 'io.avaje:avaje-http-client:1.13'
  ...
}
</pre>

<p>
  When using Client API we additionally need <em>avaje-http-api</em> and
  <em>avaje-http-client-generator</em> annotation processor.
</p>
<pre content="groovy">
dependencies {
    implementation 'com.fasterxml.jackson.core:jackson-databind:2.12.3'
    implementation 'io.avaje:avaje-http-client:1.13'

    implementation 'io.avaje:avaje-http-api:1.13'
    annotationProcessor 'io.avaje:avaje-http-client-generator:1.13'
    ...
}
</pre>


<h3 id="limitations">Limitations</h3>
<p>
  Current notable limitations are:
</p>
<ul>
  <li>No support for multipart-form body</li>
  <li>Retry (when specified) does not currently apply to <em>async</em> request processing</li>
  <li>Currently no swagger/openapi to Client API generator</li>
  <li>Currently no OpenTelemetry or OpenTracing interceptor/plugins</li>
</ul>


<h3 id="jdk-intro">JDK HttpClient Introduction</h3>
<p>
  Some introductions to the JDK HttpClient:
</p>
<ul>
  <li>OpenJDK HttpClient <a target="_blank" href="http://openjdk.java.net/groups/net/httpclient/intro.html">Introduction</a></li>
  <li>A closer look at the <a target="_blank" href="https://golb.hplar.ch/2019/01/java-11-http-client.html">Java 11 HTTP Client</a></li>
  <li>Javadoc for <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html">JDK HttpClient</a> </li>
</ul>

<h3 id="other-projects">Other JDK HttpClient projects</h3>
<p>
  Methanol is another project based on JDK HttpClient. Let me know of others and
  I'll add them to the list below.
</p>
<ul>
  <li><a target="_blank" href="https://github.com/mizosoft/methanol/">Methanol</a></li>
</ul>


<h3 id="quick-overview">Quick overview</h3>

<h4>HttpClientContext</h4>
<p>
  Create a HttpClientContext with a base URL and BodyAdapter (plus other options as necessary like retry,
  interceptors etc).
</p>
<p>
  Use HttpClientContext to create requests. Requests can be executed synchronously or asynchronously with
  CompletableFuture.
</p>

<pre content="java">
  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new JacksonBodyAdapter())
    //.bodyAdapter(new GsonBodyAdapter(new Gson()))
    .build();
</pre>

<h4>Example GET</h4>
<pre content="java">
  Customer customer = client.request()
    .path("customers/42")
    .GET()
    .bean(Customer.class);

  List<|Product> products = client.request()
    .path("products")
    .GET()
    .list(Product.class);

  HttpResponse<|String> hres = client.request()
    .path("health")
    .GET()
    .asString();
</pre>

<h4>Example GET Async</h4>
<pre content="java">
  client.request()
   .path("hello")
   .GET()
   .async().asString()  // CompletableFuture<|HttpResponse<|String>>
   .whenComplete((hres, throwable) -> {

     if (throwable != null) {
       // CompletionException
       ...
     } else {
       // HttpResponse<|String>
       int statusCode = hres.statusCode();
       String body = hres.body();
       ...
     }
   });
</pre>


<h2 id="sync-async">Sync and Async</h2>
<p>
  We can make requests in simple blocking manor or via <code>async()</code>
  in an asynchronous style using <code>CompletableFuture</code>.
</p>
<p>
  JDK HttpClient provides a number of <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">BodyHandlers</a>
  including reactive Flow based subscribers. When executing the requests in
  asynchronous style the responses are processed in a reactive way. Generally
  <code>CompletableFuture.whenComplete()</code> will be called only when the
  response is ready.
</p>
<p>
  Using <a href="#withHandler">withHandler(...)</a> we can use any of these or our own
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">HttpResponse.BodyHandler</a>
  implementation.
</p>

<h3>Loom vs Async</h3>
<p>
  With Loom we will be able to use simple blocking requests and get a similar
  behaviour as the <code>async()</code> requests. This is an important factor
  to keep in mind.
</p>
<p>
  See <a href="#10k">10K requests - Loom vs Async</a>
</p>

<h2 id="httpClientContext">HttpClientContext</h2>
<p>
  HttpClientContext is effectively a wrapper of <code>java.net.http.HttpClient</code>
  with extra features for request interceptors, body adapters, retry.
</p>
<p>
  Create a HttpClientContext with a base URL plus BodyAdapter (e.g. JacksonBodyAdapter).
  Additionally, set other options like retry and request interceptors as necessary.
</p>

<p>
  Reference <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpClientContext.Builder.html">HttpClientContext.Builder</a>
</p>

<h4>Creating HttpClientContext</h4>
<pre content="java">
  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new JacksonBodyAdapter())
    // .bodyAdapter(new GsonBodyAdapter(new Gson()))
    .build();
</pre>
<p>
  From the HttpClientContext instance we create requests and execute them.
</p>
<h4>Create and execute requests</h4>
<pre content="java">
  HttpResponse<|String> hres = client.request()
    .path("hello")
    .GET()
    .asString();
</pre>

<h2 id="json-bodyAdapter">Json - BodyAdapter</h2>
<p>
  <em>avaje-http-client</em> provides a
  <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/BodyAdapter.html">BodyAdapter</a> interface
  with implementations for <a href="https://github.com/FasterXML/jackson">Jackson</a>,
  <a href="https://github.com/google/gson">Gson</a> and <a href="https://github.com/avaje/avaje-jsonb">avaje-jsonb</a> to
  adapt request and response body content from JSON to java types and from java types to JSON.
</p>

<h3 id="json-jackson">Using Jackson</h3>
<p>
  To use Jackson for serialisation of request and response body content to and from JSON we need to:
</p>
<h4>1. Add jackson-databind dependency</h4>
<pre content="xml">
  <dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.3</version>
  </dependency>
</pre>

<h4>2. Register JacksonBodyAdapter</h4>
<p>
  Register the JacksonBodyAdapter with the HttpClientContext builder. We often provide JacksonBodyAdapter an
  ObjectMapper that has modules and configuration. For example:
</p>
<pre content="java">
  ObjectMapper objectMapper = new ObjectMapper().registerModule(new JavaTimeModule());

  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new JacksonBodyAdapter(objectMapper))
    .build();
</pre>

<h3 id="json-gson">Using Gson</h3>
<p>
  To use Gson for serialisation of request and response body content to and from JSON we need to:
</p>
<h4>1. Add gson dependency</h4>
<pre content="xml">
  <dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.9</version>
  </dependency>
</pre>

<h4>2. Register GsonBodyAdapter</h4>
<p>
  Register the GsonBodyAdapter with the HttpClientContext builder. For example:
</p>
<pre content="java">
  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new GsonBodyAdapter(new Gson()))
    .build();
</pre>

<h3 id="json-jsonb">Using avaje-jsonb</h3>
<p>
  To use <em>avaje-jsonb</em> for serialisation of request and response body content to and from JSON we need to:
</p>
<h4>1. Add avaje-jsonb dependency</h4>
<pre content="xml">
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-jsonb</artifactId>
    <version>0.15</version>
  </dependency>
</pre>

<h4>2. Register JsonbBodyAdapter</h4>
<p>
  Register the JsonbBodyAdapter with the HttpClientContext builder. We can supply a jsonb instance
  to JsonbBodyAdapter or just use defaults. For example:
</p>
<pre content="java">
  Jsonb jsonb = Jsonb.newBuilder().build();

  HttpClientContext client = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new JsonbBodyAdapter(jsonb))
    .build();
</pre>
<p>
  Note that <a href="https://github.com/avaje/avaje-jsonb">avaje-jsonb</a> uses APT source code generation to generate
  adapters for types annotated with <code>@Json</code>. This makes it a fast and light dependency, especially good for
  http clients, CLI applications and use with Graal native image.
</p>

<h2 id="request-body">Request body</h2>
<p>
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublisher.html">java.net.http.HttpRequest.BodyPublisher</a>
  is used for request body content.
  JDK HttpClient comes with a number of implementations which are great and we use. In
  addition we can use our own implementations.
</p>
<p>
  <em>avaje-http-client</em> adds URL encoded form and body adapters using Jackson and Gson
  to convert body content to/from JSON and java beans/types.
</p>

<h5>Request body</h5>
<ul>
  <li>Object which is written by the BodyAdapter, e.g. JacksonBodyAdapter writes as JSON content</li>
  <li>formParam() for url encoded form</li>
  <li>byte[], String, Path (file), InputStream</li>
  <li>Any <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublishers.html">HttpRequest.BodyPublisher</a></li>
</ul>

<h3 id="req-json">Object as JSON</h3>
<p>
  When we create the HttpClientContext we register a message body handler.
  There is a supplied <code>JacksonBodyAdapter</code> and <code>GsonBodyAdapter</code>.
  When these are registered then when we call <code>body(object)</code> passing
  an Object this uses that body adapter to write the body content as JSON.
</p>

<h4>Example: POST object as json</h4>
<pre content="java">
  Hello bean = new Hello(42, "rob", "hello world");

  HttpResponse<|Void> res = client.request()
    .path("hello")
    .body(bean)
    .POST()
    .asVoid();
</pre>

<h3 id="req-formParam">formParam</h3>
<p>
  Calling <code>formParam()</code> adds URL encoded name value pairs
  building request body content as <code>application/x-www-form-urlencoded</code>.
</p>

<h4>Example: POST using formParams</h4>
<pre content="java">
  HttpResponse<|Void> res = client.request()
    .path("register/user")
    .formParam("name", "Bazz")
    .formParam("email", "user@foo.com")
    .formParam("url", "http://foo.com")
    .formParam("startDate", "2020-12-03")
    .POST()
    .asVoid();
</pre>

<h3 id="req-path">Path (file)</h3>
<p>
  This uses <code>HttpRequest.BodyPublishers.ofFile(file)</code> to
  stream file content as the request body.
</p>

<h4>Example: PUT file Path</h4>
<pre content="java">
  Path file = ...;
  HttpResponse<|String> res = client.request()
    .path("upload")
    .body(file)
    .PUT()
    .asString();
</pre>

<h3 id="req-inputStream">InputStream</h3>
<p>
  This uses <code>HttpRequest.BodyPublishers.ofInputStream(supplier)</code>
  to stream the request body content from the InputStream.
</p>

<h4>Example: PUT InputStream</h4>
<pre content="java">
  Supplier<|InputStream> supplier = ...;

  HttpResponse<|String> res = client.request()
    .path("upload")
    .body(supplier)
    .PUT()
    .asString();
</pre>

<h3 id="req-bodyPublisher">HttpRequest.BodyPublisher</h3>
<p>
  We can pass any <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublisher.html">HttpRequest.BodyPublisher</a>
  into <code>body()</code>. Refer to <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublishers.html">HttpRequest.BodyPublishers</a>
  for ones that come with JDK HttpClient.
</p>

<h4>Example: Use any BodyPublisher</h4>
<pre content="java">
  HttpResponse<|Void> res = client.request()
    .path("whazzzup")
    .body(HttpRequest.BodyPublishers.ofString("silly example"))
    .PUT()
    .asVoid();
</pre>

<h2 id="response-body">Response body</h2>
<p>
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">java.net.http.HttpResponse.BodyHandler</a>
  is the interface used to handle response bodies. JDK HttpClient provides a number of
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html">HttpResponse.BodyHandlers</a>
  including reactive Flow based subscribers.
</p>
<p>
  <em>avaje-http-client</em> has API to use the common ones such as String, Void, byte[] etc
  and <code>withHandler()</code> to use any BodyHandler implementation.
</p>

<h4>Summary of BodyHandlers</h4>
<table style="width:100%;">
  <tr><td>discarding()</td><td>Discards the response body</td></tr>
  <tr><td>ofByteArray()</td><td>byte[]</td></tr>
  <tr><td>ofString()</td><td>String, additional charset option</td></tr>
  <tr><td>ofLines()</td><td>Stream&lt;String&gt;</td></tr>
  <tr><td>ofInputStream()</td><td>InputStream</td></tr>
  <tr><td>ofFile(Path file)</td><td>Path with various options</td></tr>
  <tr><td>ofByteArrayConsumer(...)</td><td>&nbsp;</td></tr>
  <tr><td>fromSubscriber(...)</td><td>various options</td></tr>
  <tr><td>fromLineSubscriber(...)</td><td>various options</td></tr>
</table>

<h3 id="bean">bean(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a java bean/type (typically JSON). The BodyAdapter
  decodes from <code>byte[]</code>. Gzip decoding occurs based on <em>Content-Encoding</em> header.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  Customer customer = client.request()
    .path("customers/42")
    .GET()
    .bean(Customer.class);
</pre>

<h3 id="list">list(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a list of java beans/type (typically JSON). The BodyAdapter
  decodes from <code>byte[]</code>. Gzip decoding occurs based on <em>Content-Encoding</em> header.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  List<|Customer> customers = client.request()
    .path("customers")
    .GET()
    .list(Customer.class);
</pre>

<h3 id="stream">stream(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a stream of java beans/type.
  The response is expected to be <code>application/x-json-stream</code>.
  Internally this uses <code>HttpResponse.BodyHandlers.asLines()</code> to
  get a stream of lines <code>Stream&lt;String&gt;</code>. In this case the BodyAdapter
  decodes from <code>String</code> content and there is no gzip decoding supported.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  Stream<|Customer> customers = client.request()
    .path("customers")
    .GET()
    .stream(Customer.class);
</pre>


<h3 id="asVoid">asVoid()</h3>
<p>
  Return as <code>HttpResponse&lt;Void&gt;</code> but the response
  content is still available to be read in the case of error response.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  HttpResponse<|Void> hres = client.request()
    .path("hello")
    .GET()
    .asVoid();
</pre>

<h3 id="asDiscarding">asDiscarding()</h3>
<p>
  Return as <code>HttpResponse&lt;Void&gt;</code> but the response
  content is always discarded. Unlike <code>asVoid()</code> if there is an error
  response with content error content that content will not be available.
</p>
<p>
  We use <em>asDiscarding()</em> when we only ever want the status code
  and headers etc and never want the response body.
</p>
<pre content="java">
  HttpResponse<|Void> hres = client.request()
    .path("hello")
    .GET()
    .asDiscarding();
</pre>

<h3 id="asString">asString()</h3>
<p>
  Return as <code>HttpResponse&lt;String&gt;</code>.
</p>
<pre content="java">
  HttpResponse<|String> hres = client.request()
    .path("hello")
    .GET()
    .asString();
</pre>

<h3 id="withHandler">withHandler()</h3>
<p>
  Using <code>withHandler()</code> we can use any BodyHandler to process the response.
</p>
<pre content="java">
   HttpResponse<|InputStream> hres = client.request()
    .path("hello/stream")
    .GET()
    .withHandler(BodyHandlers.ofInputStream());
</pre>



<h2 id="httpException">HttpException</h2>
<p>
  HttpException is thrown when the status code is not in 2XX range and the call is one of <a href="#bean">bean()</a>,
  <a href="#list">list()</a>, <a href="#stream">stream()</a>, <a href="#asVoid">asVoid()</a>.
</p>
<p>
  Reference API javadoc <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpException.html">HttpException</a>
</p>
<p>
  HttpException effectively wraps the HttpResponse and provides helper methods to get the response body
  as String, byte[] or bean (via body adapter typically based on Jackson or Gson).
</p>
<pre content="java">
  int statusCode = httpException.statusCode();

  // the underlying HttpResponse
  HttpResponse<?> httpResponse = httpException.httpResponse()
  int statusCode = httpResponse.statusCode();

  // helper methods to read the response body
  String errorBodyString = httpException.bodyAsString();
  byte[] errorBodyBytes  = httpException.bodyAsBytes();

  // helper method to read the response body as a bean (typically using Jackson/Gson)
  MyErrorBean errorResponse = httpException.bean(MyErrorBean.class);
</pre>

<h2 id="async">Async</h2>
<p>
  All requests can be made using <code>async</code> returning <code>CompletableFuture</code>.
  Commonly the <code>whenComplete()</code> callback will be used to process the async responses.
</p>
<p>
  The <em>bean()</em>, <em>list()</em>, <em>stream()</em> and <em>asVoid()</em> responses throw a
  <code><a href="#httpException">HttpException</a></code> if the status code is not in the 2XX range.
</p>
<p>
  Reference API javadoc <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpAsyncResponse.html">HttpAsyncResponse</a>
</p>

<h4>Example: async().asString()</h4>
<pre content="java">
  client.request()
   .path("hello/world")
   .GET()
   .async().asString()
   .whenComplete((hres, throwable) -> {

     if (throwable != null) {
       ...
     } else {
       int statusCode = hres.statusCode();
       String body = hres.body();
       ...
     }
   });
</pre>

<h4>Example: async().bean(Class&lt;T&gt;)</h4>
<pre content="java">
  client.request()
   .path("customer").path(42)
   .GET()
   .async().bean(Customer.class)
   .whenComplete((customer, throwable) -> {

     if (throwable != null) {
       HttpException httpException = (HttpException) throwable.getCause();
       int statusCode = httpException.getStatusCode();

       // maybe convert json error response body to a bean (using Jackson/Gson)
       MyErrorBean errorResponse = httpException.bean(MyErrorBean.class);
       ..

     } else {
       // use customer
       ...
     }
   });
</pre>

<h4>Example: async().withHandler()</h4>
<p>
  The example below is a line subscriber processing response content line by line.
</p>

<pre content="java">
  CompletableFuture<|HttpResponse<|Void>> future = client.request()
   .path("hello/lineStream")
   .GET().async()
   .withHandler(HttpResponse.BodyHandlers.fromLineSubscriber(new Flow.Subscriber<>() {

     @Override
     public void onSubscribe(Flow.Subscription subscription) {
       subscription.request(Long.MAX_VALUE);
     }
     @Override
     public void onNext(String item) {
       // process the line of response content
       ...
     }
     @Override
     public void onError(Throwable throwable) {
       ...
     }
     @Override
     public void onComplete() {
       ...
     }
   }))
   .whenComplete((hres, throwable) -> {
     int statusCode = hres.statusCode();
     ...
   });
</pre>

<h3 id="async-join">Testing with async() and join()</h3>
<p>
  Note that when writing tests using <code>.async()</code> we often use <code>.join()</code> such that the current
  thread waits for the async processing to complete. We can then execute asserts knowing the async processing
  has completed.
</p>

<h4>Example: join()</h4>
<pre content="java">
  client.request()
   .path("customer").path(42)
   .GET()
   .async().bean(Customer.class)
   .whenComplete((customer, throwable) -> {
     ...
   }).join(); // wait for async processing to complete

  // can assert here after the join() if desired
  assertThat(...)
</pre>

<h3 id="async-executor">Executor and common pool</h3>
<p>
  Note that <a target="_blank" href="https://bugs.openjdk.java.net/browse/JDK-8204339">JDK-8204339 - HTTP Client Dependent tasks should run in the common pool</a>
  means that by <em>default</em> async callbacks are executed using the <code>ForkJoinPool.commonPool()</code> even when an
  <code>Executor</code> is assigned to the <code>HttpClient</code>. This is can be unexpected behavior, also refer
  to this <a href="https://stackoverflow.com/questions/51907641/java-11-http-client-asynchronous-execution">stackoverflow discussion</a>
  on this behavior.
</p>
<p></p>


<h2 id="httpCall">HttpCall</h2>
<p>
  If we are creating an API and want the client code to <em>choose</em> to execute
  the request asynchronously or synchronously then we can use <code>call()</code>.
  This is similar to <em>Retrofit Call</em> for people who are familiar with that.
</p>
<p>
  The client can then choose to <em>execute()</em> the request synchronously or
  choose <em>async()</em> to execute the request asynchronously.
</p>
<p>
  Reference API javadoc <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpCall.html">HttpCall</a>
</p>

<h4>Example: call()</h4>
<pre content="java">
  HttpCall<|List<|Customer>> call = client.request()
    .path("customers")
    .GET()
    .call().list(Customer.class);

  // Either execute synchronously
  List<|Customer> customers =  call.execute();

  // Or execute asynchronously
  call.async()
    .whenComplete((customers, throwable) -> {
      ...
    });
</pre>


<h2 id="auth">Authorisation</h2>
<p>
  <em>avaje-http-client</em> has built in support for <a href="#auth-basic">basic auth</a> and
  <a href="#auth-bearer">bearer token</a> based authorisation.
</p>

<h3 id="auth-basic">Basic Auth</h3>
<p>
  We can use <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/BasicAuthIntercept.html"><code>BasicAuthIntercept</code></a>
  to intercept all requests adding a <code>Authorization: Basic ...</code> header.
</p>

<h4>Example</h4>
<pre content="java">
  HttpClientContext clientContext = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    ...
    .requestIntercept(new BasicAuthIntercept("myUsername", "myPassword"))  <|!-- HERE
    .build();
</pre>


<h3 id="auth-bearer">Bearer token Authorization - AuthTokenProvider</h3>
<p>
  For Authorization using <em>Bearer</em> tokens that are obtained and expire, implement
  <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/AuthTokenProvider.html"><code>AuthTokenProvider</code></a>
  and register that when building the HttpClientContext.
</p>

<h4>Step 1. Implement AuthTokenProvider</h4>

<pre content="java">
  class MyAuthTokenProvider implements AuthTokenProvider {

    @Override
    public AuthToken obtainToken(HttpClientRequest tokenRequest) {
      MyAuthTokenResponse res = tokenRequest
        .url("https://foo/v2/token")
        .header("content-type", "application/json")
        .body(authRequestAsJson())
        .POST()
        .bean(MyAuthTokenResponse.class);

      Instant validUntil = Instant.now().plusSeconds(res.expiresIn()).minusSeconds(60);

      return AuthToken.of(res.accessToken(), validUntil);
    }
  }
</pre>

<h4>Step 2. Register with HttpClientContext</h4>

<pre content="java">
  HttpClientContext ctx = HttpClientContext.newBuilder()
    .baseUrl("https://foo")
    ...
    .authTokenProvider(new MyAuthTokenProvider()) <|!-- HERE
    .build();
</pre>

<h4>Token obtained and set automatically</h4>
<p>
  All requests using the HttpClientContext will automatically get
  an <em>Authorization</em> header with <em>Bearer</em> token added. The token will be
  obtained for initial request and then renewed when the token has expired.
</p>


<h2 id="logging">Logging</h2>
<p>
  By default request response logging is built in (via <code>RequestLogger</code>)
  and we enable it via setting the log level to <code>DEBUG</code> or <code>TRACE</code>
  for <code>io.avaje.http.client.RequestLogger</code>
</p>
<h5>Example: Logback</h5>
<pre content="xml">
    <logger name="io.avaje.http.client.RequestLogger" level="trace"/>
</pre>

<h4 id="logging-summary">DEBUG</h4>
<p>
  Summary logging that includes the response status code and execution time is logged
  at <code>DEBUG</code> level.
</p>
<h4 id="logging-detail">TRACE</h4>
<p>
  Logging that includes the request and response <em>headers</em> plus the <em>body</em>
  content is logged at <code>TRACE</code> level.
</p>

<h3>Suppression</h3>
<p>
  Logging is suppressed for <em>Authorization</em> headers and requests used by
  <a href="#auth-bearer">AuthTokenProvider</a>. Additionally logging can be
  suppressed on requests via <code>HttpClientRequest.suppressLogging()</code>.
</p>



<h2 id="client-api">Client API</h2>
<p>
  We can define an interface and have the implementation generated. Similar to
  JAX-RS Client, Retrofit, Feign.
</p>
<p>
  When using Client API we need to add a dependency for <em>avaje-http-api</em>
  which has the annotations and also add the annotation processor <em>avaje-http-client-generator</em>.
</p>
<h3>Getting started</h3>
<p>
  Goto <a href="start#api-start">Getting started with Client API</a> for step by step
  instructions to get started.
</p>

<h3 id="at-client">@Client</h3>
<p>
  If we are creating the interface we can put <code>@Client</code> on the interface
  to indicate that the generator should generate an implementation for it.
</p>

<h5>Example client API</h5>
<pre content="java">
  @Client
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    List<|Contributor> contributors(String owner, String repo);

  }
</pre>

<h3 id="at-client-import">@Client.Import</h3>
<p>
  If the interface is already defined (in say another project) then we can instead
  use <code>@Client.Import</code> to indicate to the generator that it should
  generate an implementation for the interface defined by <code>@Client.Import</code>.
</p>
<p>
  We can put the <code>@Client.Import</code> on a <code>package-info</code> or any type.
  Most commonly we would put it on the top level <em>package-info</em>.
</p>

<h5>Example client import</h5>
<pre content="java">
@Client.Import(types = org.foo.MyInterface.class)
package org.bar;

import io.avaje.http.api.Client;
</pre>

<h3 id="obtain-api">Obtain/use API</h3>
<p>
  We obtain the API implementation via <code>httpClientContext.create(T)</code> passing
  our client interface type <em>T</em>.
</p>

<h4 id="client-create">Example: obtain implementation</h4>
<pre content="java">
  // create HttpClientContext
  final HttpClientContext httpClientContext = HttpClientContext.newBuilder()
          .baseUrl("https://api.github.com")
          .bodyAdapter(new JacksonBodyAdapter())
          .build();

  // obtain API implementation
  final Github github = httpClientContext.create(Github.class);

  // use it
  List<|Contributor> contributors = github.contributors("ebean-orm", "ebean");
</pre>

<h3 id="generated-api">Generated implementation</h3>
<p>
  The <em>avaje-http-client-generator</em> annotation processor generates the
  implementation as java source code. The generated source is typically found in:
  <code>target/generated-sources/annotations</code>
</p>
<img src="/images/http-client-api-sources.png" width="400px">

<p>&nbsp;</p>
<p>
  For more on <a href="/http-client/start#B3">IntelliJ IDEA</a> setup of generated source.
</p>

<p>&nbsp;</p>
<h3>Example: Generated source</h3>
<p>
  The generated code for the <code>Github</code> interface above is:
</p>
<pre content="java">
package org.example.httpclient;


import io.avaje.http.api.*;
import io.avaje.http.client.HttpClientContext;
import java.util.List;
import org.example.Contributor;
import org.example.Github;

@Generated("avaje-http-client-generator")
public class Github$HttpClient implements Github {

  private final HttpClientContext clientContext;

  public Github$HttpClient(HttpClientContext ctx) {
    this.clientContext = ctx;
  }

  // GET /repos/{owner}/{repo}/contributors
  @Override
  public List<|Contributor> contributors(String owner, String repo) {
    return clientContext.request()
      .path("repos").path(owner).path(repo).path("contributors")
      .GET()
      .list(Contributor.class);
  }

}
</pre>

<h3 id="api-response-types">Response types</h3>
<p>
  Below is a tabe of the API response types can be used and the resulting generated code.
</p>
<table style="width: 100%;">
  <tr>
    <th style="width: 50%;">Method response type</th>
    <th>Generated code</th>
  </tr>

  <tr><td>void</td><td>asVoid()</td></tr>
  <tr><td>String</td><td>asPlainString().body()</td></tr>

  <tr><td>T</td><td>bean(T.class)</td></tr>
  <tr><td>List&lt;T&gt;</td><td>list(T.class)</td></tr>
  <tr><td>Stream&lt;T&gt;</td><td>stream(T.class)</td></tr>
  <tr><td>HttpResponse&lt;Void&gt;</td><td>asVoid()</td></tr>
  <tr><td>HttpResponse&lt;String&gt;</td><td>asString()</td></tr>
  <tr><td>HttpResponse&lt;byte[]&gt;</td><td>asByteArray()</td></tr>
  <tr><td>HttpResponse&lt;InputStream&gt;</td><td>asInputStream()</td></tr>
  <tr><td>HttpResponse&lt;Stream&lt;String&gt;&gt;</td><td>asLines()</td></tr>
  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>


  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<!--  <tr><td><b>CompletableFuture</b></td><td>&nbsp;</td></tr>-->

  <tr><td>CompletableFuture&lt;T&gt;</T></td><td>async().bean(T.class)</td></tr>
  <tr><td>CompletableFuture&lt;List&lt;T&gt;&gt;</td><td>async().list(T.class)</td></tr>
  <tr><td>CompletableFuture&lt;Stream&lt;T&gt;&gt;</td><td>async().stream(T.class)</td></tr>

  <tr><td>CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt;</td><td>async().asVoid()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;</td><td>async().asString()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;byte[]&gt;&gt;</td><td>async().asByteArray()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;InputStream&gt;&gt;</td><td>async().asInputStream()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;Stream&lt;String&gt;&gt;&gt;</td><td>async().asLines()</td></tr>

  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<!--  <tr><td><b>HttpCall</b></td><td>&nbsp;</td></tr>-->

  <tr><td>HttpCall&lt;T&gt;</T></td><td>call().bean(T.class)</td></tr>
  <tr><td>HttpCall&lt;List&lt;T&gt;&gt;</td><td>call().list(T.class)</td></tr>
  <tr><td>HttpCall&lt;Stream&lt;T&gt;&gt;</td><td>call().stream(T.class)</td></tr>

  <tr><td>HttpCall&lt;HttpResponse&lt;Void&gt;&gt;</td><td>call().asVoid()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;String&gt;&gt;</td><td>call().asString()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;byte[]&gt;&gt;</td><td>call().asByteArray()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;InputStream&gt;&gt;</td><td>call().asInputStream()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;Stream&lt;String&gt;&gt;&gt;</td><td>call().asLines()</td></tr>

</table>

<h3 id="api-response-body">HttpResponse.BodyHandler parameter</h3>
<p>
  The method can also declare one parameter of type <code>java.net.http.HttpResponse.BodyHandler</code>
  and this will be used to handle the response body. This can be a specific generic type like
  <code>BodyHandler&lt;Path&gt;</code> or more general type like <code>BodyHandler&lt;T&gt;</code>.
</p>
<pre content="java">
  @Get("/{id}")
  HttpResponse<|Path> getWithHandler(String id, HttpResponse.BodyHandler<|Path> myHandler, String other);
</pre>
<p>
  The generated code uses the BodyHandler parameter to handle the response body. The resulting generated code
  includes <code>.withHandler(myHandler)</code>:
</p>
<pre content="java">
  // GET /{id}
  @Override
  public HttpResponse<|Path> getWithHandler(String id, BodyHandler<|Path> myHandler, String other) {
    return clientContext.request()
      .path(id)
      .queryParam("other", other)
      .GET()
      .withHandler(myHandler);
  }
</pre>
<p>
  We can also use a more general handler like <code>HttpResponse.BodyHandler&lt;T&gt;</code>.
  For example:
</p>
<pre content="java">
  @Get("/{id}")
  <|T> HttpResponse<|T> getWithGeneralHandler(String id, HttpResponse.BodyHandler<|T> myHandler);
</pre>
<p>
  The generated code uses the BodyHandler parameter to handle the response body.
</p>
<pre content="java">
  // GET /{id}
  @Override
  public <|T> HttpResponse<|T> getWithGeneralHandler(String id, BodyHandler<|T> myHandler) {
    return clientContext.request()
      .path(id)
      .GET()
      .withHandler(myHandler);
  }
</pre>

<h3 id="api-request-body">HttpRequest.BodyPublisher parameter</h3>
<p>
  The method can also declare one parameter of type <code>java.net.http.HttpRequest.BodyPublisher</code>
  and this will be used for the request body.
</p>
<pre content="java">
  @Post("/{id}/foo/{name}")
  HttpResponse<|Void> postWithBody(String id, String name, HttpRequest.BodyPublisher body);
</pre>
<p>
  The generated code uses the BodyPublisher parameter as the request body <code>.body(body)</code>
</p>
<pre content="java">
  // POST /{id}/foo/{name}
  @Override
  public HttpResponse<|Void> postWithBody(String id, String name, BodyPublisher body) {
    return clientContext.request()
      .path(id).path("foo").path(name)
      .body(body)
      .POST()
      .asVoid();
  }
</pre>

<h3 id="path">@Path</h3>
<p>
  We can optionally put <code>@Path</code> on the interface type. This path is prefixed to the
  paths defined on the verb annotations <code>@Get, @Post, @Put ...</code>.
</p>
<p>
  For example, with <code>@Path("/api/cats")</code> all the paths defined have <code>/api/cats</code> prefixed.
</p>
<pre content="java">
@Client
@Path("/api/cats")
public interface Cats {

  @Get("{id}")
  Cat byId(UUID id);

  @Get("{id}/operations")
  List<|Operation> operations(UUID id, OffsetDateTime since);

  @Get("all")
  Stream<|Cat> all();

  @Post
  void create(Cat cat);
}
</pre>
<p>
  The generated paths for the methods above all have <code>/api/cats</code> prefix:
</p>
<pre content="java">
  // GET {id}
  .path("api").path("cats").path(id)

  // GET {id}/operations
  .path("api").path("cats").path(id).path("operations")

  // GET all
  .path("api").path("cats").path("all")

  // POST
  .path("api").path("cats")
</pre>

<h3 id="pathParameters">Path parameters</h3>
<p>
  Path parameters start with <code>{</code> and end with <code>}</code> and matched
  to method parameter names. So unlike JAX-RS we do not need a <code>@PathParam</code>
  annotation.
</p>
<p>
  For example <code>{id}</code>, <code>{startDate}</code>, <code>{type}</code>
  in the path are matched to method parameters of the same name.
</p>
<pre content="java">
@Get("/{id}/{startDate}/{type}")
List<|Bazz> findBazz(long id, LocalDate startDate, String type);
</pre>
<p>
  The generated code includes <code>.path(id).path(startDate).path(type)</code>:
</p>
<pre content="java">
  // GET /{id}/{startDate}/{type}
  @Override
  public List<|Bazz> findBazz(long id, LocalDate startDate, String type) {
    return clientContext.request()
      .path(id).path(startDate).path(type)
      .GET()
      .list(Bazz.class);
  }
</pre>
<p>
  Unlike JAX-RS we do not need a <code>@PathParam</code> annotation.
</p>


<h3 id="queryParam">@QueryParam</h3>
<p>
  We explicitly specify query parameters using <code>@QueryParam</code>.
</p>
<pre content="java">
// Explicit query parameter order-by

@Get("/{bornAfter}")
List<|Cat> findCats(LocalDate bornAfter, @QueryParam("order-by") String orderBy);
</pre>
<p>
  The generated code includes <code>.queryParam("order-by", orderBy)</code>
</p>
<pre content="java">
  // GET /{bornAfter}
  @Override
  public List<|Cat> findCats(LocalDate bornAfter, String orderBy) {
    return clientContext.request()
      .path(bornAfter)
      .queryParam("order-by", orderBy)
      .GET()
      .list(Cat.class);
  }
</pre>
<h4>Implied query parameters</h4>
<p>
  Query parameters can be <em>implied</em> by not being a path parameter.
  That is, if a method parameter does not match a path parameter then it is
  implied to be a query parameter.
</p>
<p>
  The following 3 declarations are exactly the same with all 3 having
  a query parameters for <code>orderBy</code>
</p>

<pre content="java">
@Get("/{bornAfter}")
List<|Cat> findCats(LocalDate bornAfter, @QueryParam("orderBy") String orderBy);

@Get("/{bornAfter}")
List<|Cat> findCats(LocalDate bornAfter, @QueryParam String orderBy);

@Get("/{bornAfter}")
List<|Cat> findCats(LocalDate bornAfter, String orderBy);  // orderBy implied as query parameter
</pre>

<p>
  Note that we must explicitly use <code>@QueryParam</code> when the query parameter
  is not a valid java identifier. For example, if the query parameter includes a hyphen
  then we must use <code>@QueryParam</code> explicitly.
</p>

<h4>@QueryParam Map&lt;String, ?&gt;</h4>
<p>
  We can use <code>@QueryParam</code> with a <code>Map&lt;String, ?&gt;</code>, <code>Map&lt;String, String&gt;</code>
  or <code>Map&lt;String, Object&gt;</code>
</p>
<pre content="java">
  @Post
  void newCat(Cat cat, String myParam, @QueryParam Map<|String,?> extraParams);
</pre>
<p>
  The generated code includes <code>.queryParam(extraParams)</code>
</p>
<pre content="java">
  // POST
  @Override
  public void newCat(Cat cat, String myParam, Map<|String,?> extraParams) {
    clientContext.request()
      .path("api").path("cats")
      .queryParam("myParam", myParam)
      .queryParam(extraParams)
      .body(cat)
      .POST()
      .asVoid();
  }
</pre>

<h3 id="beanParam">@BeanParam</h3>
<p>
  When we have a lot of query parameters or if we have query parameters
  that are common to many endpoints then we look to use <code>@BeanParam</code>.
</p>
<p>
  We can create a bean and all the properties on the bean default to being
  query parameters and annotate this with <code>@BeanParam</code>.
</p>
<pre content="java">
public record Common(
  Long firstRow,
  Long maxRows,
  String sortBy,
  String filter) { }
</pre>
<p>
  Use a record type or any type that has getter methods, record style getter methods or public fields.
</p>
<pre content="java">
public class Common {
  public Long firstRow;
  public Long maxRows;
  public String sortBy;
  public String filter;
}
</pre>
<p>
  We annotate the method parameter with <code>@BeanParam</code>
</p>
<pre content="java">
  @Get("search/{type}")
  List<|Cat> searchCats(String type, @BeanParam Common commonParams);
</pre>
<p>
  Generated code has <code>queryParam()</code> for each of the properties:
</p>
<pre content="java">
  // GET search/{type}
  @Override
  public List<|Cat> searchCats(String type, Common commonParams) {
    return clientContext.request()
      .path("search").path(type)
      .queryParam("firstRow", commonParams.firstRow())
      .queryParam("maxRows", commonParams.maxRows())
      .queryParam("sortBy", commonParams.sortBy())
      .queryParam("filter", commonParams.filter())
      .GET()
      .list(Cat.class);
  }
</pre>

<h4>JAX-RS @BeanParam</h4>
<p>
  Our <em>@BeanParam</em> is the same as JAX-RS <em>@BeanParam</em> except the properties
  default to being query parameters. With JAX-RS we need to explicitly annotate each of the properties.
  We can do this because we also have <a href="#form">@Form</a> and "Form beans".
</p>

<h4>BeanParam with @Header properties</h4>
<p>
  The properties on a "bean" default to being query parameters. We put
  <a href="#header">@Header</a> on properties that are instead headers.
</p>
<pre content="java">
public record Common(
  Long firstRow,
  Long maxRows,
  String sortBy,
  String filter,
  @Header("X-Mod")
  String modification) { }
</pre>
<p>
  We then get the <code>modification</code> value set as a <em>header</em>.
</p>
<pre content="java">
.header("X-Mod", commonParams.modification())
</pre>


<h3 id="form">@Form</h3>
<p>
  If a method has both <code>@Post</code> and <code>@Form</code> then the
  method parameters default to be form parameters.
</p>
<p>
  In the following example name, email and url all default to be form parameters.
</p>
<pre content="java">
  @Form @Post("register")
  void register(String name, String email, String url);
</pre>
<p>
  The generated code includes <code>.formParam()</code> for <em>name, email and url</em>.
</p>
<pre content="java">
  // POST register
  @Override
  public void register(String name, String email, String url) {
    clientContext.request()
      .path("register")
      .formParam("name", name)
      .formParam("email", email)
      .formParam("url", url)
      .POST()
      .asVoid();
  }
</pre>

<h3 id="formParam">@FormParam</h3>
<p>
  For the example above we could alternatively use explicit <code>@FormParam</code>
  on each of the form parameters rather than <code>@Form</code>. We then get:
</p>
<pre content="java">
@Post("register")
void register(@FormParam String name, @FormParam String email, @FormParam String url);
</pre>
<p>
  The expectation is that we most often would use <code>@Form</code> because it reduces
  "annotation noise" and that we will very rarely use <code>@FormParam</code>. Potentially
  we only use @FormParam if the parameter name includes hyphen or similar characters that
  are not valid Java/Kotlin identifiers.
</p>

<h4>@FormParam Map&lt;String, ?&gt;</h4>
<p>
  We can use <code>@FormParam</code> with a <code>Map&lt;String, ?&gt;</code>, <code>Map&lt;String, String&gt;</code>
  or <code>Map&lt;String, Object&gt;</code>.
</p>
<pre content="java">
  @Put("{id}")
  void register(UUID id, @FormParam Map<|String, ?> params);
</pre>
<p>
  The generated code includes <code>.formParam(params)</code>
</p>
<pre content="java">
  // PUT {id}
  @Override
  public void register(UUID id, Map<|String,?> params) {
    clientContext.request()
      .path("api").path("cats").path(id)
      .formParam(params)
      .PUT()
      .asVoid();
  }
</pre>

<h2 id="formBeans">@Form "Form Beans"</h2>
<p>
  In the case where we are posting a form with a lot of parameters we can define a bean with
  properties for each of the form parameters rather than have a method with lots of arguments.
</p>

<pre content="java">
public record RegisterForm(String name, String email, String url) { }
</pre>
<pre content="java">
@Form @Post("register")
void register(RegisterForm myForm);
</pre>
The generated code for the above is:
<pre content="java">
  // POST register
  @Override
  public void register(RegisterForm myForm) {
    clientContext.request()
      .path("register")
      .formParam("name", myForm.name())
      .formParam("email", myForm.email())
      .formParam("url", myForm.url())
      .POST()
      .asVoid();
  }
</pre>
<p>
  "Form beans" are nice with forms with lots of properties because they de-clutter our code
  and the generated code takes care of putting the values into our bean properties so that
  we don't have to write that code.
</p>
<p>
  This use of <em>@Form</em> is very similar to JAX-RS <em>@BeanParam</em> except that the
  bean properties default be being form parameters. With JAX-RS we would put a <code>@FormParam</code>
  on every property that is a form parameter which becomes a lot of annotation noise on a large form.
</p>

<h4>Form beans with @QueryParam, @Header properties</h4>
<p>
  The properties on a "form bean" default to being form parameters. We put <em>@QueryParam</em>,
  <em>@Header</em> on properties that are instead query params, headers or cookies.
</p>
<pre content="java">
public record RegisterForm(
  String name,
  String email,
  String url,
  @QueryParam Boolean overrideFlag,
  @Header String xModified) { }
</pre>
<p>
  The generated code includes <code>queryParam()</code> and <code>header()</code> for
  those parameters:
</p>
<pre content="java">
  // POST register
  @Override
  public void register(RegisterForm myForm) {
    clientContext.request()
      .path("register")
      .formParam("name", myForm.name())
      .formParam("email", myForm.email())
      .formParam("url", myForm.url())
      .queryParam("overrideFlag", myForm.overrideFlag())
      .header("X-Modified", myForm.xModified())
      .POST()
      .asVoid();
  }
</pre>


<h3 id="header">@Header</h3>
<p>
  Use <code>@Header</code> for a header parameter.
  It the header parameter name is not explicitly specified then
  it is the <em>init caps snake case</em> of the parameter name.
</p>
<p>
  <code>userAgent</code> -> <code>User-Agent</code>
</p>
<p>
  <code>lastModified</code> -> <code>Last-Modified</code>
</p>

<pre content="java">
@Post
Bar postIt(Foo payload, @Header("User-Agent") String userAgent); // explicit

@Post
Bar postIt(Foo payload, @Header String userAgent); // User-Agent

@Get
Bazz find(@Header String lastModified); // Last-Modified
</pre>

<h4>@Header Map&lt;String, ?&gt;</h4>
<p>
  We can use <code>@Header</code> with a <code>Map&lt;String, ?&gt;</code>, <code>Map&lt;String, String&gt;</code>
  or <code>Map&lt;String, Object&gt;</code>.
</p>
<pre content="java">
  @Get("{type}")
  List<|Cat> searchByType(String type, String query, @Header Map<|String, ?> myHeaders);
</pre>
<p>
  The generated code includes <code>.header(myHeaders)</code>
</p>
<pre content="java">
  // GET {type}
  @Override
  public List<|Cat> searchByType(String type, String query, Map<|String,?> myHeaders) {
    return clientContext.request()
      .header(myHeaders)
      .path("api").path("cats").path(type)
      .queryParam("query", query)
      .GET()
      .list(Cat.class);
  }
</pre>

<h2 id="10k">10K requests - Loom vs Async</h2>
<p>
  The following is a very quick and rough comparison of running 10,000 requests
  using <em>Async</em> vs <em>Loom</em>.
</p>
<p>
  The intention is to test the thought that in a "future Loom world" the
  desire to use <code>async()</code> execution with HttpClient reduces.
</p>
<p>
  TLDR: Caveat, caveat, more caveats ... initial testing shows Loom to be just a
  touch faster (~10%) than async.
</p>
<p>
  To run my tests I use <a target="_blank" href="https://github.com/avaje/avaje-jex">Jex</a> as the server
  (Jetty based) and have it running using Loom. For whatever testing you do
  you will need a server that can handle a very large number of concurrent requests.
</p>
<p>
  The Loom blocking request (make 10K of these)
</p>
<pre content="java">
  HttpResponse<|String> hres =  httpClient.request()
    .path("s200")
    .GET()
    .asString();
</pre>
<p>
  The equivalent async request (make 10K of these joining the CompletableFuture's).
</p>
<pre content="java">
  CompletableFuture<|HttpResponse<|String>> future = httpClient.request()
    .path("s200")
    .GET()
    .async()
    .asString()
    .whenComplete((hres, throwable) -> {
      ...
    });
</pre>


<h3 id="10k-async">10K requests using Async and reactive streams</h3>
<p>
  Use <code>.async()</code> to execute the requests which internally is using JDK
  HttpClient's reactive streams. The <code>whenComplete()</code> callback is invoked
  when the response is ready. Collect all the resulting CompletableFuture
  and wait for them all to complete.
</p>
<p>
Outline:
</p>
<pre content="java">
  // Collect all the CompletableFuture's
  List<|CompletableFuture<|HttpResponse<|String>>> futures = new ArrayList<>();

  for (int i = 0; i < 10_000; i++) {
    futures.add(httpClient.request().path("s200")
      .GET()
      .async().asString()
      .whenComplete((hres, throwable) -> {
          // confirm 200 response etc
          ...
      }));
  }

  // wait for all requests to complete via join() ...
  CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
</pre>

<h3 id="10k-loom">10K requests using Loom</h3>
<p>
  With Loom Java 17 EA Release we can use <code>Executors.newVirtualThreadExecutor()</code>
  to return an ExecutorService that uses Loom Virtual Threads. These are backed
  by "Carrier threads" (via ForkedJoinPool).
</p>
<p>
Outline:
</p>
<pre content="java">
  // use Loom's Executors.newVirtualThreadExecutor()
  try (ExecutorService executorService = Executors.newVirtualThreadExecutor()) {
      for (int i = 0; i < 10_000; i++) {
          executorService.submit(this::task);
      }
  }
</pre>
<pre content="java">
  private void task() {
    HttpResponse<|String> hres =
      httpClient.request().path("s200")
       .GET()
       .asString();

    // confirm 200 response etc
    ...
  }
</pre>
<p>
Caveat: Proper performance benchmarks are really hard and take a lot of effort.
</p>
<p>
  Running some "rough/approx performance comparison tests" using <em>Loom</em>
  build <code>17 EA 2021-09-14 / (build 17-loom+7-342)</code> vs <em>Async</em> for my environment
  and 10K request scenarios has loom execution around 10% faster than async.
</p>
<p>
  It looks like Loom and Async run in pretty much the same time although it
  currently looks that Loom is just a touch faster (perhaps due to how it does
  park/unpark). More investigation required.
</p>
<p>
  Date: 2021-06 <br/>
  Build: <code>17 EA 2021-09-14 / (build 17-loom+7-342)</code>.
</p>
<pre>
  openjdk version "17-loom" 2021-09-14
  OpenJDK Runtime Environment (build 17-loom+7-342)
  OpenJDK 64-Bit Server VM (build 17-loom+7-342, mixed mode, sharing)
</pre>

</body>
</html>
