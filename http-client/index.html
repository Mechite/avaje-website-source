<html>
<head>
  <meta name="layout" content="_layout/base-http-client.html"/>
  <meta name="bread2" content="client" href="/http-client/"/>
  <#assign index="active">
</head>
<body>

<h1 id="overview">avaje http client</h1>

<table width="100%">
  <tr>
    <th>License</th>
    <th>Source</th>
    <th>API Docs</th>
    <th>Issues</th>
    <th>Releases</th>
  </tr>
  <tr>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/blob/master/LICENSE">Apache2</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client">Github</a></td>
    <td><a target="_blank" href="/apidocs/avaje-http-client">Javadoc</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/issues">Github</a></td>
    <td><a target="_blank" href="https://github.com/avaje/avaje-http-client/releases">Latest 1.9</a></td>
  </tr>
</table>
<p>&nbsp;</p>

<h3>Wrap JDK HttpClient</h3>
<p>
  A lightweight wrapper to the <a target="_blank" href="http://openjdk.java.net/groups/net/httpclient/intro.html">JDK 11+ Java Http Client</a>.
</p>
<ul>
  <li>Requires Java 11+ (recommend 11.0.8+)</li>
  <li>Adds a fluid API for building URL and payload</li>
  <li>Adds JSON marshalling/unmarshalling of request and response using Jackson or Gson</li>
  <li>Gzip encoding/decoding</li>
  <li>Logging of request/response logging</li>
  <li>Interception of request/response</li>
  <li>Built in support for authorization via Basic Auth and Bearer Token</li>
  <li>Provides async and sync API</li>
</ul>

<h3>Client API generation</h3>
<p>
  Optionally we can define a java interface with annotations and have a Java
  annotation processor generate the client implementation (similar to Retrofit,
  Feign and JAX-RS client).
</p>
<ul>
  <li>Generates the implementation as source code via annotation processing</li>
  <li>Targets <em>avaje-http-client / JDK HttpClient</em> only</li>
</ul>
<p>
  This is similar to <a target="_blank" href="https://github.com/square/retrofit">Retrofit</a>,
  <a target="_blank" href="https://github.com/OpenFeign/feign">Feign</a> and JAX-RS client for people familiar with
  those projects. This client API generation targets <em>avaje-http-client / JDK HttpClient</em> only
  and uses source code generation via annotation processing.
</p>

<h5>Example client API</h5>
<pre content="java">
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    List<|Contributor> contributors(String owner, String repo);
  }
</pre>
<h5>API allowing async or sync use via HttpCall</h5>
<pre content="java">
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    HttpCall<|Contributor> contributors(String owner, String repo);
  }
</pre>
<p>
  The Client API can also be a useful target given a Openapi/Swagger spec.
  Given a Openapi spec generate a client API (or client and server API).
  The plan is to add a maven plugin that takes an openapi spec and generates
  the associated API (but this does not exist just yet).
</p>


<h2 id="getting-started">Getting started</h2>
<ul>
  <li><a href="/http-client/start">Get started with the base client</a></li>
  <li><a href="/http-client/start#api-start">Get started with Client API generation</a></li>
</ul>

<h2 id="dependencies">Dependencies</h2>

<h3 id="maven">Maven</h3>
<p>
  Add <em>avaje-http-client</em> as a dependency.
</p>
<pre content="xml">
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-client</artifactId>
    <version>1.9</version>
  </dependency>
</pre>

<h4>Client API generation</h4>
<p>
  For the client API generation we need to add <em>avaje-http-api</em> as a dependency.
</p>
<pre content="xml">
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-api</artifactId>
    <version>1.9</version>
  </dependency>
</pre>

<h4>Client API - Annotation processor</h4>
<p>
  Add the <em>avaje-http-client-generator</em> annotation processor.
  We can add it as a <em>provided</em> scope dependency or ...
</p>
<pre content="xml">
  <!-- Annotation processors -->
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-http-client-generator</artifactId>
    <version>1.9</version>
    <scope>provided</scope>
  </dependency>
</pre>

<p>
  If there are other annotation processors and they are specified via
  <em>maven-compiler-plugin</em> <em>annotationProcessorPaths</em>
  then we add <em>avaje-http-client-generator</em> there instead.
</p>
<pre content="xml">
<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <configuration>
    <annotationProcessorPaths> <!-- All annotation processors specified here -->
      <path>
        <groupId>io.avaje</groupId>
        <artifactId>avaje-http-client-generator</artifactId>
        <version>1.9</version>
      </path>
      <path>
          ... other annotation processor ...
      </path>
    </annotationProcessorPaths>
  </configuration>
</plugin>
</pre>

<h3 id="gradle">Gradle</h3>
<p>
  See <a href="gradle">Gradle</a> for adding the dependencies using Gradle.
</p>



<h3 id="limitations">Limitations</h3>
<p>
  Current notable limitations are:
</p>
<ul>
  <li>No support for multipart-form body</li>
  <li>Retry (when specified) does not currently apply to <em>async</em> request processing</li>
  <li>Currently no swagger/openapi to Client API generator</li>
  <li>Currently no OpenTelemetry or OpenTracing interceptor/plugins</li>
</ul>


<h3 id="jdk-intro">JDK HttpClient Introduction</h3>
<p>
  Some introductions to the JDK HttpClient:
</p>
<ul>
  <li>JDK HttpClient <a target="_blank" href="http://openjdk.java.net/groups/net/httpclient/intro.html">Introduction</a></li>
  <li>Javadoc for <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpClient.html">JDK HttpClient</a> </li>
  <li>A closer look at the <a target="_blank" href="https://golb.hplar.ch/2019/01/java-11-http-client.html">Java 11 HTTP Client</a></li>
</ul>

<h3 id="other-projects">Other JDK HttpClient projects</h3>
<p>
  Methanol is another project based on JDK HttpClient. Let me know of others and
  I'll add them to the list below.
</p>
<ul>
  <li><a href="https://github.com/mizosoft/methanol/">Methanol</a></li>
</ul>


<h3 id="quick-overview">Quick overview</h3>

<h4>HttpClientContext</h4>
<p>
  Create a HttpClientContext with a base URL and BodyAdapter (plus other options as necessary like retry,
  interceptors etc).
</p>
<p>
  Use HttpClientContext to create requests. Requests can be executed synchronously or asynchronously with
  CompletableFuture.
</p>

<pre content="java">
  HttpClientContext httpClientContext = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    .bodyAdapter(new JacksonBodyAdapter())
    //.bodyAdapter(new GsonBodyAdapter(new Gson()))
    .build();
</pre>

<h4>Example GET</h4>
<pre content="java">
  HttpResponse<|String> hres = httpClientContext.request()
    .path("hello")
    .GET()
    .asString();
</pre>

<h4>Example GET Async</h4>
<pre content="java">
  httpClientContext.request()
   .path("hello")
   .GET()
   .async().asString()  // CompletableFuture<|HttpResponse<|String>>
   .whenComplete((hres, throwable) -> {

     if (throwable != null) {
       // CompletionException
       ...
     } else {
       // HttpResponse<|String>
       int statusCode = hres.statusCode();
       String body = hres.body();
       ...
     }
   });
</pre>


<h2 id="sync-async">Sync and Async</h2>
<p>
  We can make requests in simple blocking manor or via <code>async()</code>
  in an asynchronous style using <code>CompletableFuture</code>.
</p>
<p>
  JDK HttpClient provides a number of <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">BodyHandlers</a>
  including reactive Flow based subscribers. When executing the requests in
  asynchronous style the responses are processed in a reactive way. Generally
  <code>CompletableFuture.whenComplete()</code> will be called only when the
  response is ready.
</p>
<p>
  Using <a href="#withHandler">withHandler(...)</a> we can use any of these or our own
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">HttpResponse.BodyHandler</a>
  implementation.
</p>

<h3>Loom vs Async</h3>
<p>
  With Loom we will be able to use simple blocking requests and get a similar
  behaviour as the <code>async()</code> requests. This is an important factor
  to keep in mind.
</p>
<p>
  See <a href="#10k">10K requests - Loom vs Async</a>
</p>

<h2 id="httpClientContext">HttpClientContext</h2>
<p>
  HttpClientContext is effectively a wrapper of <a href="">java.net.http.HttpClient</a>
  with extra features for request interceptors, body adapters, retry.
</p>
<p>
  Create a HttpClientContext with a base URL plus BodyAdapter (e.g. JacksonBodyAdapter).
  Additionally set other options like retry and request interceptors as necessary.
</p>

<p>
  Reference <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpClientContext.Builder.html">HttpClientContext.Builder</a>
</p>

<h4>Creating HttpClientContext</h4>
<pre content="java">
  HttpClientContext httpClientContext =
    HttpClientContext.newBuilder()
      .baseUrl(baseUrl)
      .bodyAdapter(new JacksonBodyAdapter())
      // .bodyAdapter(new GsonBodyAdapter(new Gson()))
      .build();
</pre>
<p>
  From the HttpClientContext instance we create requests and execute them.
</p>
<h4>Create and execute requests</h4>
<pre content="java">
  HttpResponse<|String> hres = httpClientContext.request()
    .path("hello")
    .GET()
    .asString();
</pre>

<h2 id="request-body">Request body</h2>
<p>
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublisher.html">java.net.http.HttpRequest.BodyPublisher</a>
  is used for request body content.
  JDK HttpClient comes with a number of implementations which are great and we use. In
  addition we can use our own implementations.
</p>
<p>
  <em>avaje-http-client</em> adds URL encoded form and body adapters using Jackson and Gson
  to convert body content to/from JSON and java beans/types.
</p>

<h5>Request body</h5>
<ul>
  <li>Object which is written by the BodyAdapter, e.g. JacksonBodyAdapter writes as JSON content</li>
  <li>formParam() for url encoded form</li>
  <li>byte[], String, Path (file), InputStream</li>
  <li>Any <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublishers.html">HttpRequest.BodyPublisher</a></li>
</ul>

<h3 id="req-json">Object as JSON</h3>
<p>
  When we create the HttpClientContext we register a message body handler.
  There is a supplied <code>JacksonBodyAdapter</code> and <code>GsonBodyAdapter</code>.
  When these are registered then when we call <code>body(object)</code> passing
  an Object this uses that body adapter to write the body content as JSON.
</p>

<h4>Example: POST object as json</h4>
<pre content="java">
  Hello bean = new Hello(42, "rob", "hello world");

  HttpResponse<|Void> res = clientContext.request()
    .path("hello")
    .body(bean)
    .POST()
    .asVoid();
</pre>

<h3 id="req-formParam">formParam</h3>
<p>
  Calling <code>formParam()</code> adds URL encoded name value pairs
  building request body content as <code>application/x-www-form-urlencoded</code>.
</p>

<h4>Example: POST using formParams</h4>
<pre content="java">
  HttpResponse<|Void> res = clientContext.request()
    .path("register/user")
    .formParam("name", "Bazz")
    .formParam("email", "user@foo.com")
    .formParam("url", "http://foo.com")
    .formParam("startDate", "2020-12-03")
    .POST()
    .asVoid();
</pre>

<h3 id="req-path">Path (file)</h3>
<p>
  This uses <code>HttpRequest.BodyPublishers.ofFile(file)</code> to
  stream file content as the request body.
</p>

<h4>Example: PUT file Path</h4>
<pre content="java">
  Path file = ...;
  HttpResponse<|String> res = clientContext.request()
    .path("upload")
    .body(file)
    .PUT()
    .asString();
</pre>

<h3 id="req-inputStream">InputStream</h3>
<p>
  This uses <code>HttpRequest.BodyPublishers.ofInputStream(supplier)</code>
  to stream the request body content from the InputStream.
</p>

<h4>Example: PUT InputStream</h4>
<pre content="java">
  Supplier<|InputStream> supplier = ...;

  HttpResponse<|String> res = clientContext.request()
    .path("upload")
    .body(supplier)
    .PUT()
    .asString();
</pre>

<h3 id="req-bodyPublisher">HttpRequest.BodyPublisher</h3>
<p>
  We can pass any <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublisher.html">HttpRequest.BodyPublisher</a>
  into <code>body()</code>. Refer to <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpRequest.BodyPublishers.html">HttpRequest.BodyPublishers</a>
  for ones that come with JDK HttpClient.
</p>

<h4>Example: Use any BodyPublisher</h4>
<pre content="java">
  HttpResponse<|Void> res = clientContext.request()
    .path("whazzzup")
    .body(HttpRequest.BodyPublishers.ofString("silly example"))
    .PUT()
    .asVoid();
</pre>

<h2 id="response-body">Response body</h2>
<p>
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandler.html">java.net.http.HttpResponse.BodyHandler</a>
  is the interface used to handle response bodies. JDK HttpClient provides a number of
  <a target="_blank" href="https://docs.oracle.com/en/java/javase/11/docs/api/java.net.http/java/net/http/HttpResponse.BodyHandlers.html">HttpResponse.BodyHandlers</a>
  including reactive Flow based subscribers.
</p>
<p>
  <em>avaje-http-client</em> has API to use the common ones such as String, Void, byte[] etc
  and <code>withHandler()</code> to use any BodyHandler implementation.
</p>

<h4>Summary of BodyHandlers</h4>
<table style="width:100%;">
  <tr><td>discarding()</td><td>Discards the response body</td></tr>
  <tr><td>ofByteArray()</td><td>byte[]</td></tr>
  <tr><td>ofString()</td><td>String, additional charset option</td></tr>
  <tr><td>ofLines()</td><td>Stream&lt;String&gt;</td></tr>
  <tr><td>ofInputStream()</td><td>InputStream</td></tr>
  <tr><td>ofFile(Path file)</td><td>Path with various options</td></tr>
  <tr><td>ofByteArrayConsumer(...)</td><td>&nbsp;</td></tr>
  <tr><td>fromSubscriber(...)</td><td>various options</td></tr>
  <tr><td>fromLineSubscriber(...)</td><td>various options</td></tr>
</table>

<h3 id="bean">bean(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a java bean/type (typically JSON). The BodyAdapter
  decodes from <code>byte[]</code>. Gzip decoding occurs based on <em>Content-Encoding</em> header.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  Customer customer = clientContext.request()
    .path("customers/42")
    .GET()
    .bean(Customer.class);
</pre>

<h3 id="list">list(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a list of java beans/type (typically JSON). The BodyAdapter
  decodes from <code>byte[]</code>. Gzip decoding occurs based on <em>Content-Encoding</em> header.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  List<|Customer> customers = clientContext.request()
    .path("customers")
    .GET()
    .list(Customer.class);
</pre>

<h3 id="stream">stream(Class&lt;T&gt;)</h3>
<p>
  Return the response via BodyAdapter as a stream of java beans/type.
  The response is expected to be <code>application/x-json-stream</code>.
  Internally this uses <code>HttpResponse.BodyHandlers.asLines()</code> to
  get a stream of lines <code>Stream&lt;String&gt;</code>. In this case the BodyAdapter
  decodes from <code>String</code> content and there is no gzip decoding supported.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  Stream<|Customer> customers = clientContext.request()
    .path("customers")
    .GET()
    .stream(Customer.class);
</pre>


<h3 id="asVoid">asVoid()</h3>
<p>
  Return as <code>HttpResponse&lt;Void&gt;</code> but the response
  content is still available to be read in the case of error response.
</p>
<p>
  If the HTTP status code is in the error range this throws a <a href="#httpException">HttpException</a>.
  From the HttpException we can get the underlying HttpResponse and error
  response body.
</p>
<pre content="java">
  HttpResponse<|Void> hres = clientContext.request()
    .path("hello")
    .GET()
    .asVoid();
</pre>

<h3 id="asDiscarding">asDiscarding()</h3>
<p>
  Return as <code>HttpResponse&lt;Void&gt;</code> but the response
  content is always discarded. Unlike <code>asVoid()</code> if there is an error
  response with content error content that content will not be available.
</p>
<p>
  We use <em>asDiscarding()</em> when we only ever want the status code
  and headers etc and never want the response body.
</p>
<pre content="java">
  HttpResponse<|Void> hres = clientContext.request()
    .path("hello")
    .GET()
    .asDiscarding();
</pre>

<h3 id="asString">asString()</h3>
<p>
  Return as <code>HttpResponse&lt;String&gt;</code>.
</p>
<pre content="java">
  HttpResponse<|String> hres = clientContext.request()
    .path("hello")
    .GET()
    .asString();
</pre>

<h3 id="withHandler">withHandler()</h3>
<p>
  Using <code>withHandler()</code> we can use any BodyHandler to process the response.
</p>
<pre content="java">
   HttpResponse<|InputStream> hres = clientContext.request()
    .path("hello/stream")
    .GET()
    .withHandler(BodyHandlers.ofInputStream());
</pre>



<h2 id="httpException">HttpException</h2>
<p>
  HttpException is thrown when the status code is not in 2XX range and the call is one of <a href="#bean">bean()</a>,
  <a href="#list">list()</a>, <a href="#stream">stream()</a>, <a href="#asVoid">asVoid()</a>.
</p>
<p>
  Reference API javadoc <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpException.html">HttpException</a>
</p>
<p>
  HttpException effectively wraps the HttpResponse and provides helper methods to get the response body
  as String, byte[] or bean (via body adapter typically based on Jackson or Gson).
</p>
<pre content="java">
  int statusCode = httpException.statusCode();

  // the underlying HttpResponse
  HttpResponse<?> httpResponse = httpException.httpResponse()
  int statusCode = httpResponse.statusCode();

  // helper methods to read the response body
  String errorBodyString = httpException.bodyAsString();
  byte[] errorBodyBytes  = httpException.bodyAsBytes();

  // helper method to read the response body as a bean (typically using Jackson/Gson)
  MyErrorBean errorResponse = httpException.bean(MyErrorBean.class);
</pre>

<h2 id="async">Async</h2>
<p>
  All requests can be made using <code>async</code> returning <code>CompletableFuture</code>.
  Commonly the <code>whenComplete()</code> callback will be used to process the async responses.
</p>
<p>
  The <em>bean()</em>, <em>list()</em>, <em>stream()</em> and <em>asVoid()</em> responses throw a
  <code><a href="#httpException">HttpException</a></code> if the status code is not in the 2XX range.
</p>
<p>
  Reference API javadoc <a href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpAsyncResponse.html">HttpAsyncResponse</a>
</p>

<h4>Example: async().asString()</h4>
<pre content="java">
  clientContext.request()
   .path("hello/world")
   .GET()
   .async().asString()
   .whenComplete((hres, throwable) -> {

     if (throwable != null) {
       ...
     } else {
       int statusCode = hres.statusCode();
       String body = hres.body();
       ...
     }
   });
</pre>

<h4>Example: async().bean(Class&lt;T&gt;)</h4>
<pre content="java">
  clientContext.request()
   .path("customer").path(42)
   .GET()
   .async().bean(Customer.class)
   .whenComplete((customer, throwable) -> {

     if (throwable != null) {
       HttpException httpException = (HttpException) throwable.getCause();
       int statusCode = httpException.getStatusCode();

       // maybe convert json error response body to a bean (using Jackson/Gson)
       MyErrorBean errorResponse = httpException.bean(MyErrorBean.class);
       ..

     } else {
       // use customer
       ...
     }
   });
</pre>

<h4>Example: async().withHandler()</h4>
<p>
  The example below is a line subscriber processing response content line by line.
</p>

<pre content="java">
  CompletableFuture<|HttpResponse<|Void>> future = clientContext.request()
   .path("hello/lineStream")
   .GET().async()
   .withHandler(HttpResponse.BodyHandlers.fromLineSubscriber(new Flow.Subscriber<>() {

     @Override
     public void onSubscribe(Flow.Subscription subscription) {
       subscription.request(Long.MAX_VALUE);
     }
     @Override
     public void onNext(String item) {
       // process the line of response content
       ...
     }
     @Override
     public void onError(Throwable throwable) {
       ...
     }
     @Override
     public void onComplete() {
       ...
     }
   }))
   .whenComplete((hres, throwable) -> {
     int statusCode = hres.statusCode();
     ...
   });
</pre>

<h2 id="httpCall">HttpCall</h2>
<p>
  If we are creating an API and want the client code to <em>choose</em> to execute
  the request asynchronously or synchronously then we can use <code>call()</code>.
  This is similar to <em>Retrofit Call</em> for people who are familiar with that.
</p>
<p>
  The client can then choose to <em>execute()</em> the request synchronously or
  choose <em>async()</em> to execute the request asynchronously.
</p>
<p>
  Reference API javadoc <a href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/HttpCall.html">HttpCall</a>
</p>

<h4>Example: call()</h4>
<pre content="java">
  HttpCall<|List<|Customer>> call =
    clientContext.request()
      .path("customers")
      .GET()
      .call().list(Customer.class);

  // Either execute synchronously
  List<|Customer> customers =  call.execute();

  // Or execute asynchronously
  call.async()
    .whenComplete((customers, throwable) -> {
      ...
    });
</pre>


<h2 id="auth">Authorisation</h2>
<p>
  <em>avaje-http-client</em> has built in support for <a href="#auth-basic">basic auth</a> and
  <a href="#auth-bearer">bearer token</a> based authorisation.
</p>

<h3 id="auth-basic">Basic Auth</h3>
<p>
  We can use <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/BasicAuthIntercept.html"><code>BasicAuthIntercept</code></a>
  to intercept all requests adding a <code>Authorization: Basic ...</code> header.
</p>

<h4>Example</h4>
<pre content="java">
  HttpClientContext clientContext = HttpClientContext.newBuilder()
    .baseUrl(baseUrl)
    ...
    .requestIntercept(new BasicAuthIntercept("myUsername", "myPassword"))  <|!-- HERE
    .build();
</pre>


<h3 id="auth-bearer">Bearer token Authorization - AuthTokenProvider</h3>
<p>
  For Authorization using <em>Bearer</em> tokens that are obtained and expire, implement
  <a target="_blank" href="/apidocs/avaje-http-client/io.avaje.http.client/io/avaje/http/client/AuthTokenProvider.html"><code>AuthTokenProvider</code></a>
  and register that when building the HttpClientContext.
</p>

<h4>Step 1. Implement AuthTokenProvider</h4>

<pre content="java">
  class MyAuthTokenProvider implements AuthTokenProvider {

    @Override
    public AuthToken obtainToken(HttpClientRequest tokenRequest) {
      MyAuthTokenResponse res = tokenRequest
        .url("https://foo/v2/token")
        .header("content-type", "application/json")
        .body(authRequestAsJson())
        .POST()
        .bean(MyAuthTokenResponse.class);

      Instant validUntil = Instant.now().plusSeconds(res.expiresIn()).minusSeconds(60);

      return AuthToken.of(res.accessToken(), validUntil);
    }
  }
</pre>

<h4>Step 2. Register with HttpClientContext</h4>

<pre content="java">
  HttpClientContext ctx = HttpClientContext.newBuilder()
    .baseUrl("https://foo")
    ...
    .authTokenProvider(new MyAuthTokenProvider()) <|!-- HERE
    .build();
</pre>

<h4>Token obtained and set automatically</h4>
<p>
  All requests using the HttpClientContext will automatically get
  an <em>Authorization</em> header with <em>Bearer</em> token added. The token will be
  obtained for initial request and then renewed when the token has expired.
</p>


<h2 id="client-api">Client API</h2>
<p>
  We can define an interface and have the implementation generated. Similar to
  JAX-RS Client, Retrofit, Feign.
</p>
<p>
  When using Client API we need to add a dependency for <em>avaje-http-api</em>
  which has the annotations and also add the annotation processor <em>avaje-http-client-generator</em>.
</p>
<h3>Getting started</h3>
<p>
  Goto <a href="start#api-start">Getting started with Client API</a> for step by step
  instructions to get started.
</p>

<h3 id="at-client">@Client</h3>
<p>
  If we are creating the interface we can put <code>@Client</code> on the interface
  to indicate that the generator should generate an implementation for it.
</p>

<h5>Example client API</h5>
<pre content="java">
  @Client
  interface GitHub {

    @Get("/repos/{owner}/{repo}/contributors")
    List<|Contributor> contributors(String owner, String repo);

  }
</pre>

<h3 id="at-client-import">@Client.Import</h3>
<p>
  If the interface is already defined (in say another project) then we can instead
  use <code>@Client.Import</code> to indicate to the generator that it should
  generate an implementation for the interface defined by <code>@Client.Import</code>.
</p>
<p>
  We can put the <code>@Client.Import</code> on a <code>package-info</code> or any type.
  Most commonly we would put it on the top level <em>package-info</em>.
</p>

<h5>Example client import</h5>
<pre content="java">
@Client.Import(types = org.foo.MyInterface.class)
package org.bar;

import io.avaje.http.api.Client;
</pre>

<h3 id="obtain-api">Obtain/use API</h3>
<p>
  We obtain the API implementation via <code>httpClientContext.create(T)</code> passing
  our client interface type <em>T</em>.
</p>

<h4 id="client-create">Example: obtain implementation</h4>
<pre content="java">
  // create HttpClientContext
  final HttpClientContext httpClientContext = HttpClientContext.newBuilder()
          .baseUrl("https://api.github.com")
          .bodyAdapter(new JacksonBodyAdapter())
          .build();

  // obtain API implementation
  final Github github = httpClientContext.create(Github.class);

  // use it
  List<|Contributor> contributors = github.contributors("ebean-orm", "ebean");
</pre>

<h3 id="generated-api">Generated implementation</h3>
<p>
  The <em>avaje-http-client-generator</em> annotation processor generates the
  implementation as java source code. The generated source is typically found in:
  <code>target/generated-sources/annotations</code>
</p>
<img src="/images/http-client-api-sources.png" width="400px">

<p>&nbsp;</p>
<h3>Example: Generated source</h3>
<p>
  The generated code for the <code>Github</code> interface above is:
</p>
<pre content="java">
package org.example.httpclient;


import io.avaje.http.api.*;
import io.avaje.http.client.HttpClientContext;
import java.util.List;
import org.example.Contributor;
import org.example.Github;

@Generated("avaje-http-client-generator")
public class Github$HttpClient implements Github {

  private final HttpClientContext clientContext;

  public Github$HttpClient(HttpClientContext ctx) {
    this.clientContext = ctx;
  }

  // GET /repos/{owner}/{repo}/contributors
  @Override
  public List<|Contributor> contributors(String owner, String repo) {
    return clientContext.request()
      .path("repos").path(owner).path(repo).path("contributors")
      .GET()
      .list(Contributor.class);
  }

}
</pre>

<h3 id="api-response-types">Response types</h3>
<p>
  Below is a tabe of the API response types can be used and the resulting generated code.
</p>
<table width="100%">
  <tr>
    <th width="50%">Method response type</th>
    <th>Generated code</th>
  </tr>

  <tr><td>void</td><td>asVoid()</td></tr>
  <tr><td>String</td><td>asPlainString().body()</td></tr>

  <tr><td>T</td><td>bean(T.class)</td></tr>
  <tr><td>List&lt;T&gt;</td><td>list(T.class)</td></tr>
  <tr><td>Stream&lt;T&gt;</td><td>stream(T.class)</td></tr>
  <tr><td>HttpResponse&lt;Void&gt;</td><td>asVoid()</td></tr>
  <tr><td>HttpResponse&lt;String&gt;</td><td>asString()</td></tr>
  <tr><td>HttpResponse&lt;byte[]&gt;</td><td>asByteArray()</td></tr>
  <tr><td>HttpResponse&lt;InputStream&gt;</td><td>asInputStream()</td></tr>
  <tr><td>HttpResponse&lt;Stream&lt;String&gt;&gt;</td><td>asLines()</td></tr>
  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>


  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<!--  <tr><td><b>CompletableFuture</b></td><td>&nbsp;</td></tr>-->

  <tr><td>CompletableFuture&lt;T&gt;</T></td><td>async().bean(T.class)</td></tr>
  <tr><td>CompletableFuture&lt;List&lt;T&gt;&gt;</td><td>async().list(T.class)</td></tr>
  <tr><td>CompletableFuture&lt;Stream&lt;T&gt;&gt;</td><td>async().stream(T.class)</td></tr>

  <tr><td>CompletableFuture&lt;HttpResponse&lt;Void&gt;&gt;</td><td>async().asVoid()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;String&gt;&gt;</td><td>async().asString()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;byte[]&gt;&gt;</td><td>async().asByteArray()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;InputStream&gt;&gt;</td><td>async().asInputStream()</td></tr>
  <tr><td>CompletableFuture&lt;HttpResponse&lt;Stream&lt;String&gt;&gt;&gt;</td><td>async().asLines()</td></tr>

  <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
<!--  <tr><td><b>HttpCall</b></td><td>&nbsp;</td></tr>-->

  <tr><td>HttpCall&lt;T&gt;</T></td><td>call().bean(T.class)</td></tr>
  <tr><td>HttpCall&lt;List&lt;T&gt;&gt;</td><td>call().list(T.class)</td></tr>
  <tr><td>HttpCall&lt;Stream&lt;T&gt;&gt;</td><td>call().stream(T.class)</td></tr>

  <tr><td>HttpCall&lt;HttpResponse&lt;Void&gt;&gt;</td><td>call().asVoid()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;String&gt;&gt;</td><td>call().asString()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;byte[]&gt;&gt;</td><td>call().asByteArray()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;InputStream&gt;&gt;</td><td>call().asInputStream()</td></tr>
  <tr><td>HttpCall&lt;HttpResponse&lt;Stream&lt;String&gt;&gt;&gt;</td><td>call().asLines()</td></tr>

</table>

<h3 id="api-response-body">HttpResponse.BodyHandler parameter</h3>
<p>
  The method can also declare one parameter of type <code>java.net.http.HttpResponse.BodyHandler</code>
  and this will be used to handle the response body. This can be a specific generic type like
  <code>BodyHandler&lt;Path&gt;</code> or more general type like <code>BodyHandler&lt;T&gt;</code>.
</p>
<pre content="java">
  @Get("/{id}")
  HttpResponse<|Path> getWithHandler(String id, HttpResponse.BodyHandler<|Path> myHandler, String other);
</pre>
<p>
  The generated code uses the BodyHandler parameter to handle the response body. The resulting generated code is:
</p>
<pre content="java">
  // GET /{id}
  @Override
  public HttpResponse<|Path> getWithHandler(String id, BodyHandler<|Path> myHandler, String other) {
    return clientContext.request()
      .path(id)
      .queryParam("other", other)
      .GET()
      .withHandler(myHandler);
  }
</pre>
<p>
  We can also use a more general handler like <code>HttpResponse.BodyHandler&lt;T&gt;</code>.
  For example:
</p>
<pre content="java">
  @Get("/{id}")
  <|T> HttpResponse<|T> getWithGeneralHandler(String id, HttpResponse.BodyHandler<|T> myHandler);
</pre>
<p>
  The generated code uses the BodyHandler parameter to handle the response body. The resulting generated code is:
</p>
<pre content="java">
  // GET /{id}
  @Override
  public <|T> HttpResponse<|T> getWithGeneralHandler(String id, BodyHandler<|T> myHandler) {
    return clientContext.request()
      .path(id)
      .GET()
      .withHandler(myHandler);
  }
</pre>

<h3 id="api-request-body">HttpRequest.BodyPublisher parameter</h3>
<p>
  The method can also declare one parameter of type <code>java.net.http.HttpRequest.BodyPublisher</code>
  and this will be used for the request body.
</p>
<pre content="java">
  @Post("/{id}/foo/{name}")
  HttpResponse<|Void> postWithBody(String id, String name, HttpRequest.BodyPublisher body);
</pre>
<p>
  The generated code uses the BodyPublisher parameter as the request body. The resulting generated code is:
</p>
<pre content="java">
  // POST /{id}/foo/{name}
  @Override
  public HttpResponse<|Void> postWithBody(String id, String name, BodyPublisher body) {
    return clientContext.request()
      .path(id).path("foo").path(name)
      .body(body)
      .POST()
      .asVoid();
  }
</pre>



<h2 id="10k">10K requests - Loom vs Async</h2>
<p>
  The following is a very quick and rough comparison of running 10,000 requests
  using <em>Async</em> vs <em>Loom</em>.
</p>
<p>
  The intention is to test the thought that in a "future Loom world" the
  desire to use <code>async()</code> execution with HttpClient reduces.
</p>
<p>
  TLDR: Caveat, caveat, more caveats ... initial testing shows Loom to be just a
  touch faster (~10%) than async.
</p>
<p>
  To run my tests I use <a href="https://github.com/avaje/avaje-jex">Jex</a> as the server
  (Jetty based) and have it running using Loom. For whatever testing you do
  you will need a server that can handle a very large number of concurrent requests.
</p>
<p>
  The Loom blocking request (make 10K of these)
</p>
<pre content="java">
  HttpResponse<|String> hres =  httpClient.request()
    .path("s200")
    .GET()
    .asString();
</pre>
<p>
  The equivalent async request (make 10K of these joining the CompletableFuture's).
</p>
<pre content="java">
  CompletableFuture<|HttpResponse<|String>> future = httpClient.request()
    .path("s200")
    .GET()
    .async()
    .asString()
    .whenComplete((hres, throwable) -> {
      ...
    });
</pre>


<h3 id="10k-async">10K requests using Async and reactive streams</h3>
<p>
  Use <code>.async()</code> to execute the requests which internally is using JDK
  HttpClient's reactive streams. The <code>whenComplete()</code> callback is invoked
  when the response is ready. Collect all the resulting CompletableFuture
  and wait for them all to complete.
</p>
<p>
Outline:
</p>
<pre content="java">
  // Collect all the CompletableFuture's
  List<|CompletableFuture<|HttpResponse<|String>>> futures = new ArrayList<>();

  for (int i = 0; i < 10_000; i++) {
    futures.add(httpClient.request().path("s200")
      .GET()
      .async().asString()
      .whenComplete((hres, throwable) -> {
          // confirm 200 response etc
          ...
      }));
  }

  // wait for all requests to complete via join() ...
  CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
</pre>

<h3 id="10k-loom">10K requests using Loom</h3>
<p>
  With Loom Java 17 EA Release we can use <code>Executors.newVirtualThreadExecutor()</code>
  to return an ExecutorService that uses Loom Virtual Threads. These are backed
  by "Carrier threads" (via ForkedJoinPool).
</p>
<p>
Outline:
</p>
<pre content="java">
  // use Loom's Executors.newVirtualThreadExecutor()
  try (ExecutorService executorService = Executors.newVirtualThreadExecutor()) {
      for (int i = 0; i < 10_000; i++) {
          executorService.submit(this::task);
      }
  }
</pre>
<pre content="java">
  private void task() {
    HttpResponse<|String> hres =
      httpClient.request().path("s200")
       .GET()
       .asString();

    // confirm 200 response etc
    ...
  }
</pre>
<p>
Caveat: Proper performance benchmarks are really hard and take a lot of effort.
</p>
<p>
  Running some "rough/approx performance comparison tests" using <em>Loom</em>
  build <code>17 EA 2021-09-14 / (build 17-loom+7-342)</code> vs <em>Async</em> for my environment
  and 10K request scenarios has loom execution around 10% faster than async.
</p>
<p>
  It looks like Loom and Async run in pretty much the same time although it
  currently looks that Loom is just a touch faster (perhaps due to how it does
  park/unpark). More investigation required.
</p>
<p>
  Date: 2021-06 <br/>
  Build: <code>17 EA 2021-09-14 / (build 17-loom+7-342)</code>.
</p>
<pre>
  openjdk version "17-loom" 2021-09-14
  OpenJDK Runtime Environment (build 17-loom+7-342)
  OpenJDK 64-Bit Server VM (build 17-loom+7-342, mixed mode, sharing)
</pre>

</body>
</html>
