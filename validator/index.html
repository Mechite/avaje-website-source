<html>

<head>
  <meta name="layout" content="_layout/base-validator.html" />
  <meta name="bread1" content="validator" href="/validator/" />
  <#assign index="active">
</head>

<body>

  <h1 id="overview">Avaje Validator</h1>

  <table style="width: 100%;">
    <tr>
      <th>License</th>
      <th>Source</th>
      <th>API Docs</th>
      <th>Issues</th>
      <th>Releases</th>
    </tr>
    <tr>
      <td><a target="_blank" href="https://github.com/avaje/avaje-validator/blob/master/LICENSE">Apache2</a></td>
      <td><a target="_blank" href="https://github.com/avaje/avaje-validator">Github</a></td>
      <td><a target="_blank" href="/apidocs/avaje-validator">Javadoc</a></td>
      <td><a target="_blank" href="https://github.com/avaje/avaje-validator/issues">Github</a></td>
      <td><a href="https://github.com/avaje/avaje-validator/releases"><img
            src="https://img.shields.io/maven-central/v/io.avaje/avaje-validator.svg?label=Maven%20Central"></a></td>
    </tr>
  </table>

  <p><br><br>
    Reflection-free pojo validation via apt source code generation.
    A light (~85kb + generated code) source code generation style alternative to Hibernate Validation. (code generation
    vs reflection)
  </p>

  <ul>
    <li>Annotate java classes with <code>@Valid</code> (or use <code>@Valid.Import</code> for types we "don't own" or
      can't annotate)</li>
    <li>Supports Avaje/Jakarta/Javax Constraint Annotations</li>
    <li>Validation Group Support</li>
    <li>Composable Contraint Annotations</li>
  </ul>

  <h2 id="quick-start">Quick Start</h2>
  <h4>
    1. Add <em>avaje.validator</em> dependencies.
  </h4>
  <pre content="xml">
<dependency>
  <groupId>io.avaje</groupId>
  <artifactId>avaje.validator</artifactId>
  <version>${avaje.validator.version}</version>
</dependency>
<!-- Alternatively can use Jakarta/Javax Constraints-->
<dependency>
  <groupId>io.avaje</groupId>
  <artifactId>validator-constraints</artifactId>
  <version>${avaje.validator.version}</version>
</dependency>
</pre>

  <h4>
    2. Add the annotation processor to your pom.
  </h4>
  <pre content="xml">
  <!-- Annotation processors -->
  <dependency>
    <groupId>io.avaje</groupId>
    <artifactId>avaje-validator-generator</artifactId>
    <version>${avaje.validator.version}</version>
    <scope>provided</scope>
  </dependency>
</pre>

  <h4>3. Add <code>@Valid</code> onto types we want to serialize.</h4>
  <p>
    <br>The avaje-validator-generator annotation processor will generate a ValidationAdapter as java source code for
    each type annotated with <code>@Valid</code>.
    These will be automatically registered with validator using a service loader mechanism.
    <br>For types we can not annotate with <code>@Valid</code> we can instead use <code>@ImportValidPojo</code>.
  </p>
  <pre content="java">
  @Valid
  public class RingedCity {

    @NotBlank
    private String street;

    @NotEmpty(message="must not be empty")
    private List<@NotBlank(message="{message.bundle.key}") String> judges; // message will be interpolated from bundle

    @Valid //cascaded validation
    @NotNull(groups=Sunlight.class) //groups
    private DarkEater dragon;

    //add getters/setters
  }
</pre>

  <p>Also works with records:</p>

  <pre content="java">
  @Valid
  public record RingedCity(
        @NotBlank String street,
        List<@NotBlank(message="{message.bundle.key}") String> judges,
        @Valid @NotNull(groups=Sunlight.class) DarkEater dragon
        ) {}
</pre>

  <h4>
    4. Validate you POJO
  </h4>

  <pre content="java">
  // build using defaults
  Validator validator = Validator.builder().build();

  Customer customer = ...;

  // will throw a `ConstraintViolationException` containing all the failed constraint violations
  validator.validate(customer);

  // validate with explicit locale for error message lookup
  validator.validate(customer, Locale.ENGLISH);

  // validate with groups
  validator.validate(customer, Locale.ENGLISH, Group1.class);
</pre>

  <h2 id="jpms">Java Module Setup</h2>
  <p>
    If using java modules, in the <code>module-info.java</code> we need to:
  </p>
  <ol>
    <li>Add a <em>requires</em> clause for <em>io.avaje.validator</em></li>
    <li>Add a <em>provides</em> clause for <em>io.avaje.validator.validator.GeneratedComponent</em></li>
  </ol>

  <h5>Example module-info</h5>
  <pre content="java">
  import io.avaje.validation.Validator.GeneratedComponent;
  import io.avaje.validation.spi.ValidatorCustomizer;

  module org.example {

    requires io.avaje.validator;

    //if defining validation customizers add:
    provides ValidatorCustomizer with org.example.validator.MyCustomizer;

    // you must define the fully qualified class name of the generated classes. if you use an import statement, compilation will fail
    provides GeneratedComponent with org.example.validator.GeneratedComponent;

    //if running using Jlink application images with avaje-inject add:
    //requires io.avaje.validator.plugin;

    //if running using Jlink application images with both avaje-http and inject add:
    //requires io.avaje.validator.http;
  }
  </pre>
  <p>
    In the example above, <code>org.example.validator.GeneratedComponent</code> is generated code typically found in
    <code>target/generated-sources/annotations</code>.
  </p>


  <h2 id="integration">Avaje Integrations</h2>
  <p>
    When used with Avaje Inject, a default <code>Validator</code> and <code>AOPMethodValidator</code> instance will be
    provided. The following properties can be added to configure the default instance.
  </p>

  <pre content="java">
    validation.resourcebundle.names // name of ResourceBundle files to load
    validation.locale.default //default local to use (default Locale.getDefault())
    validation.locale.addedLocales //Additional Locales this validator should support
    validation.temporal.tolerance.value //temporal tolerance value
    validation.temporal.tolerance.chronoUnit //What ChronoUnit enum value to use for temporal tolerance (default MILLIS)
    </pre>

  </p>


  <h2 id="constraint">Declaring and Validating Bean Constraints</h2>
  <p>
    Types annotated with <code>@Valid</code> are picked up by the avaje-validator-generator at compile time and an
    adapter is generated to perform validations.
  </p>
  <h3>Field Validation</h3>
  <p>
    Constraints can be expressed by annotating a field of a class with an annotation.
  </p>
  <pre content="java">
  @Valid
  public class Car {

    @NotNull
    private String manufacturer;

    @AssertTrue
    private boolean isRegistered;

    //getters...
}
</pre>

  <h3>Getter Validation</h3>
  <p>
    It is also possible to annotate methods that have no arguments to validate the return type.
  </p>
  <pre content="java">
  @Valid
  public class Car {

    private String manufacturer;

    private boolean isRegistered;

    @NotNull
    public String getManufacturer() {
        return manufacturer;
    }

    @AssertTrue
    public boolean isRegistered() {
        return isRegistered;
    }
}
</pre>

  <h3>Container element constraints</h3>
  <p>
    It is possible to specify constraints directly on the type argument of a parameterized type: these constraints are
    called container element constraints.
  </p>

  <p>
    Avaje Validator supports container element constraints specified on the following standard Java containers:
  <ul>
    <li>implementations of <code>java.util.Iterable</code> (e.g. Lists, Sets),</li>
    <li>implementations of <code>java.util.Map</code>, with support for keys and values,</li>
  </ul>
  </p>

  <pre content="java">
    @Valid
    public class Ship {
      @Valid
      private Map<@NotBlank String, @Valid @NotNull CrewMate> crew;

      @Valid
      private List<@NotBlank String> tasks;
    //getters...
    }
</pre>

  <h4>Optional element constraints</h4>
  <p>
    Optional and their variants work slightly differently than regular container types. The values are automatically
    unwrapped, so constraints must be placed the the field itself instead of the container.
  </p>

  <pre content="java">
    @Valid
    public record CurseBearer(
        @NotBlank(message = "It'll happen to you too") Optional<String> name, //the value contained within is validated
        @Positive OptionalInt estus,
        @Positive(message = "You Died") OptionalLong souls,
        @Positive(message = "vigor check failed") OptionalDouble vigor) {}
</pre>

  <h3>Cascaded Validation</h3>
  <p>
    Avaje Validator supports validating complete object graphs. To do so, just annotate a field or property representing
    a reference to another object with <code>@Valid</code>
  </p>
  <pre content="java">
@Valid
public class Ship {

  @NotNull
  @Valid // an adapter will be generated for Crewmate as well
  private Crewmate mate;

  //...
}

class Crewmate {

  @NotNull
  private String name;

  @AssertFalse
  private boolean sus;

  //...
}
</pre>

  <h3>Inherited Constraints</h3>
  <p>
    When a class implements an interface or extends another class, all constraint annotations declared on the super-type
    apply in the same manner as the constraints specified on the class itself. To make things clearer, let's have a look
    at the following example:
  </p>
  <pre content="java">
  class Car {

      private String manufacturer;

      @NotNull
      public String getManufacturer() {
          return manufacturer;
      }

      //...
  }

  class RentalCar extends Car {

    private String rentalStation;

    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    //...
}
</pre>

  <p>
    Here the class <code> RentalCar</code> is a subclass of <code>Car</code> and adds the property
    <code> rentalStation</code> . If an instance of <code>RentalCar</code> is
    validated, not only the <code>@NotNull</code> constraint on <code>rentalStation</code> is evaluated, but also the
    constraint on <code>manufacturer</code> from the parent class.

    The same would be true, if <code>Car</code> was not a superclass but an interface implemented by
    <code>RentalCar</code>.

    Constraint annotations are aggregated if methods are overridden. So if <code>RentalCar</code> overrode the
    <code>getManufacturer()</code> method from <code>Car</code>, any constraints annotated at the overriding method
    would be
    evaluated in addition to the <code>@NotNull</code> constraint from the superclass.
  </p>

  <h2 id="methods">Method Validation</h2>
  <p>
    Constraints can not only be applied to POJOs and their properties, but also to the
    parameters and return values of the methods of Java types.
  </p>

  <h3>@ValidMethod</h3>
  <p>
    Adding <code>@ValidMethod</code> to a method will generate classes that contain adapters for the methods
    parameters/return types. These classes can be wired by a JSR-330 compliant DI library for use in AOP to execute the
    validations.
  </p>

  <p>
    Avaje Validator has an integration with Avaje Inject to provide a default AOP method validator for bean classes.
    So when used with avaje inject, the below method will be proxied and validated.
  </p>
  <pre content="java">
@Singleton
public class GraphService {

  @ValidMethod
  @PositiveOrZero
  public long calculate(@Positive int x, @Negative int x){
    ...
  }
}
</pre>

  <h2 id="message">Constraint Error Messages</h2>

  <h3>Declaring Messages</h3>
  <p>
    Constraint violation messages are initially retrieved from the <em>message</em> annotation value. Each constraint
    defines its default message value using the <em>message</em>. At declaration time, the default value can be
    overridden with a specific value as shown below:
  </p>

  <pre content="java">
    @Valid
    public class Car {

      @NotNull(message = "The manufacturer name must not be null")
      private String manufacturer;
  }
</pre>

  <h4>ResourceBundle Loading</h4>

  <p>
    If the annotation value begins and ends with brackets, avaje will check the configured ResourceBundles using the
    bracket contents. If any bundle contains an entry for a given message parameter, the messeage parameter will be
    replaced with the corresponding value from the bundle. This step will be executed recursively in case the
    replaced value begins/ends with brackets.
  </p>

  <p>The resource bundle is expected to be provided by the application
    developer, e.g. by adding a file named ValidationMessages.properties to the classpath. You can also create localized
    error messages by providing locale specific variations of bundles, such as ValidationMessages_en_US.properties.
    When validating, you can provide the locale to use to lookup messages. By default, <code>Locale#getDefault()</code>
    will be used when looking up messages in the bundle.
  </p>

  <p> To register bundles with the validator, add the filename to the validator builder, or directly add the
    ResourceBundle instance to the builder.
  </p>

  <pre content="java">
    @Valid
    public class Car {
      // will search configured bundles for bundle.key
      @NotNull(message = "{bundle.key}")
      private String manufacturer;
  }
</pre>


  <h4>Adding ResourceBundles</h4>

  You can provide ResourceBundles

  <h3>Message Interpolation</h3>
  <p>
    If a constraint is violated, its descriptor will be interpolated by the currently configured
    <code>MessageInterpolator</code>. The interpolated error message can then be retrieved from the resulting
    constraint violation by calling <code>ConstraintViolation#getMessage()</code>. Below is the signature for
    <code>MessageInterpolator</code>.
  </p>

  <pre content="java">
    public interface MessageInterpolator {

      /**
       * Interpolate the given message with the annotation attributes
       *
       * @param template The template loaded from annotation/resourceBundle
       * @param attributes The Constraint annotation's attributes
       * @return The interpolated validation error message
       */
      String interpolate(String template, Map<String, Object> attributes);
    }
</pre>

  <h4>Default Message Interpolation</h4>
  <p>
    If no <code>MessageInterpolator</code> is provided, the default interpolator reads the
    string for brackets, then replaces them with the corresponding annotation attribute. See the below example.
  </p>
  <pre content="java">
    @Size(
            min = 2,
            max = 14,
            message = "Value must be between {min} and {max} characters long"
    )
    private Collection<String> values;
</pre>

  <p>
    by default, the error message will be interpolated to: <em>Value must be between 2 and 14 characters long</em>.
  </p>

  <h3>Grouping Constraints</h3>
  <p>
    All validation methods on <code>Validator</code> take a var-arg argument <code>groups</code>. Groups allow you to
    restrict the set of constraints applied during validation. One use case for validation groups are UI wizards where
    in each step only a specified subset of constraints should get validated. The groups targeted are passed as var-arg
    parameters to the appropriate validate method.
  </p>

  <p>
    Let's have a look at an example. Below we have a set of classes to be validated
  </p>

  <pre content="java">
    class Car {

      @NotNull //Group-less constraints will only be executed when no groups are requested in validation.
      private String manufacturer;

      @NotNull
      @Size(min = 2, max = 14)
      private String licensePlate;

      @Min(2)
      private int seatCount;

      //Constraints with groups execute if there is a group matching in the validation request.
      @AssertTrue(
              message = "The car has to pass the vehicle inspection first",
              groups = CarChecks.class
      )
      private boolean passedVehicleInspection;

      @Valid
      private Driver driver;

      // getters and setters ...
    }

   class Person {

      @NotNull
      private String name;
      // getters and setters ...
  }

  class Driver extends Person {
    @Min(
            value = 18,
            message = "You have to be 18 to drive a car",
            groups = DriverChecks.class
    )
    public int age;

    @AssertTrue(
            message = "You first have to pass the driving test",
            groups = DriverChecks.class
    )
    public boolean hasDrivingLicense;

    // getters and setters ...
}

</pre>

  <pre content="java">
    // create a car and check that everything is ok with it.
    Car car = new Car( "Morris", "DD-AB-123", 2 );
    validator.validate(car); // exception will be thrown if validation fails

    // but has it passed the vehicle inspection?
    validator.validate( car, CarChecks.class );

    // now let's add a driver. He is 18, but has not passed the driving test yet
    Driver john = new Driver( "John Doe" );
    john.setAge( 18 );
    car.setDriver( john );
    constraintViolations = validator.validate( car, DriverChecks.class );
    assertEquals( 1, constraintViolations.size() );
    assertEquals(
            "You first have to pass the driving test",
            constraintViolations.iterator().next().getMessage()
    );

    // ok, John passes the test
    john.passedDrivingTest( true );
    assertEquals(0, validator.validate( car, DriverChecks.class ).size() );

    // just checking that everything is in order now
    assertEquals(0, validator.validate(car, Default.class, DriverChecks.class).size());
</pre>

  <p>
    The first validate() call is done using no explicit group. There are no
    validation errors, even though the property passedVehicleInspection is per default false as the constraint defined
    on this property does not belong to the default group.

    The next validation using the CarChecks group fails until the car passes the vehicle inspection. Adding a driver to
    the car and validating against DriverChecks again yields one constraint violation due to the fact that the driver
    has not yet passed the driving test. Only after setting passedDrivingTest to true the validation against
    DriverChecks passes.

    The last validate() call finally shows that all constraints are passing by validating against all defined groups.
  </p>

</body>

</html>
